#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MixedRealityCaptureFramework

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_classes.hpp"
#include "MixedRealityCaptureFramework_structs.hpp"
#include "OpenCVLensDistortion_structs.hpp"


namespace SDK
{

// Class MixedRealityCaptureFramework.MrcFrameworkSettings
// 0x00A8 (0x00D0 - 0x0028)
class UMrcFrameworkSettings final : public UObject
{
public:
	struct FSoftObjectPath                        DefaulVideoSource;                                 // 0x0028(0x0018)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DefaultVideoProcessingMat;                         // 0x0040(0x0018)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DefaultRenderTarget;                               // 0x0058(0x0018)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DefaultDistortionDisplacementMap;                  // 0x0070(0x0018)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DefaulGarbageMatteMesh;                            // 0x0088(0x0018)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DefaulGarbageMatteMaterial;                        // 0x00A0(0x0018)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DefaulGarbageMatteTarget;                          // 0x00B8(0x0018)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MrcFrameworkSettings">();
	}
	static class UMrcFrameworkSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMrcFrameworkSettings>();
	}
};
static_assert(alignof(UMrcFrameworkSettings) == 0x000008, "Wrong alignment on UMrcFrameworkSettings");
static_assert(sizeof(UMrcFrameworkSettings) == 0x0000D0, "Wrong size on UMrcFrameworkSettings");
static_assert(offsetof(UMrcFrameworkSettings, DefaulVideoSource) == 0x000028, "Member 'UMrcFrameworkSettings::DefaulVideoSource' has a wrong offset!");
static_assert(offsetof(UMrcFrameworkSettings, DefaultVideoProcessingMat) == 0x000040, "Member 'UMrcFrameworkSettings::DefaultVideoProcessingMat' has a wrong offset!");
static_assert(offsetof(UMrcFrameworkSettings, DefaultRenderTarget) == 0x000058, "Member 'UMrcFrameworkSettings::DefaultRenderTarget' has a wrong offset!");
static_assert(offsetof(UMrcFrameworkSettings, DefaultDistortionDisplacementMap) == 0x000070, "Member 'UMrcFrameworkSettings::DefaultDistortionDisplacementMap' has a wrong offset!");
static_assert(offsetof(UMrcFrameworkSettings, DefaulGarbageMatteMesh) == 0x000088, "Member 'UMrcFrameworkSettings::DefaulGarbageMatteMesh' has a wrong offset!");
static_assert(offsetof(UMrcFrameworkSettings, DefaulGarbageMatteMaterial) == 0x0000A0, "Member 'UMrcFrameworkSettings::DefaulGarbageMatteMaterial' has a wrong offset!");
static_assert(offsetof(UMrcFrameworkSettings, DefaulGarbageMatteTarget) == 0x0000B8, "Member 'UMrcFrameworkSettings::DefaulGarbageMatteTarget' has a wrong offset!");

// Class MixedRealityCaptureFramework.MrcFocalDriver
// 0x0000 (0x0000 - 0x0000)
class IMrcFocalDriver final
{
public:
	float GetHorizontalFieldOfView() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MrcFocalDriver">();
	}
	static class IMrcFocalDriver* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMrcFocalDriver>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IMrcFocalDriver) == 0x000001, "Wrong alignment on IMrcFocalDriver");
static_assert(sizeof(IMrcFocalDriver) == 0x000001, "Wrong size on IMrcFocalDriver");

// Class MixedRealityCaptureFramework.MrcGarbageMatteCaptureComponent
// 0x0040 (0x0880 - 0x0840)
class UMrcGarbageMatteCaptureComponent final : public USceneCaptureComponent2D
{
public:
	TSubclassOf<class AMrcGarbageMatteActor>      GarbageMatteActorClass;                            // 0x0840(0x0008)(ZeroConstructor, Transient, Config, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AMrcGarbageMatteActor*                  GarbageMatteActor;                                 // 0x0848(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AMrcGarbageMatteActor*>          SpawnedActors;                                     // 0x0850(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class USceneComponent>         TrackingOriginPtr;                                 // 0x0860(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TScriptInterface<class IMrcFocalDriver>       FocalDriver;                                       // 0x0868(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_878[0x8];                                      // 0x0878(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyCalibrationData(const class UMrcCalibrationData* ConfigData);
	void GetGarbageMatteData(TArray<struct FMrcGarbageMatteSaveData>* GarbageMatteDataOut);
	void SetFocalDriver(TScriptInterface<class IMrcFocalDriver> InFocalDriver);
	void SetGarbageMatteActor(class AMrcGarbageMatteActor* NewActor);
	void SetTrackingOrigin(class USceneComponent* TrackingOrigin);
	class AMrcGarbageMatteActor* SpawnNewGarbageMatteActor(class USceneComponent* TrackingOrigin);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MrcGarbageMatteCaptureComponent">();
	}
	static class UMrcGarbageMatteCaptureComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMrcGarbageMatteCaptureComponent>();
	}
};
static_assert(alignof(UMrcGarbageMatteCaptureComponent) == 0x000010, "Wrong alignment on UMrcGarbageMatteCaptureComponent");
static_assert(sizeof(UMrcGarbageMatteCaptureComponent) == 0x000880, "Wrong size on UMrcGarbageMatteCaptureComponent");
static_assert(offsetof(UMrcGarbageMatteCaptureComponent, GarbageMatteActorClass) == 0x000840, "Member 'UMrcGarbageMatteCaptureComponent::GarbageMatteActorClass' has a wrong offset!");
static_assert(offsetof(UMrcGarbageMatteCaptureComponent, GarbageMatteActor) == 0x000848, "Member 'UMrcGarbageMatteCaptureComponent::GarbageMatteActor' has a wrong offset!");
static_assert(offsetof(UMrcGarbageMatteCaptureComponent, SpawnedActors) == 0x000850, "Member 'UMrcGarbageMatteCaptureComponent::SpawnedActors' has a wrong offset!");
static_assert(offsetof(UMrcGarbageMatteCaptureComponent, TrackingOriginPtr) == 0x000860, "Member 'UMrcGarbageMatteCaptureComponent::TrackingOriginPtr' has a wrong offset!");
static_assert(offsetof(UMrcGarbageMatteCaptureComponent, FocalDriver) == 0x000868, "Member 'UMrcGarbageMatteCaptureComponent::FocalDriver' has a wrong offset!");

// Class MixedRealityCaptureFramework.MixedRealityCaptureActor
// 0x0040 (0x0368 - 0x0328)
class AMixedRealityCaptureActor final : public AActor
{
public:
	class UMixedRealityCaptureComponent*          CaptureComponent;                                  // 0x0328(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoAttachToVRPlayer;                             // 0x0330(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoHidePlayer;                                   // 0x0331(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideAttachmentsWithPlayer;                        // 0x0332(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoBroadcast;                                    // 0x0333(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_334[0x2C];                                     // 0x0334(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            DebugVisualizerMesh;                               // 0x0360(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UTexture* GetCaptureTexture();
	bool IsBroadcasting();
	void OnTargetDestroyed(class AActor* DestroyedActor);
	void SetAutoBroadcast(const bool bNewValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MixedRealityCaptureActor">();
	}
	static class AMixedRealityCaptureActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMixedRealityCaptureActor>();
	}
};
static_assert(alignof(AMixedRealityCaptureActor) == 0x000008, "Wrong alignment on AMixedRealityCaptureActor");
static_assert(sizeof(AMixedRealityCaptureActor) == 0x000368, "Wrong size on AMixedRealityCaptureActor");
static_assert(offsetof(AMixedRealityCaptureActor, CaptureComponent) == 0x000328, "Member 'AMixedRealityCaptureActor::CaptureComponent' has a wrong offset!");
static_assert(offsetof(AMixedRealityCaptureActor, bAutoAttachToVRPlayer) == 0x000330, "Member 'AMixedRealityCaptureActor::bAutoAttachToVRPlayer' has a wrong offset!");
static_assert(offsetof(AMixedRealityCaptureActor, bAutoHidePlayer) == 0x000331, "Member 'AMixedRealityCaptureActor::bAutoHidePlayer' has a wrong offset!");
static_assert(offsetof(AMixedRealityCaptureActor, bHideAttachmentsWithPlayer) == 0x000332, "Member 'AMixedRealityCaptureActor::bHideAttachmentsWithPlayer' has a wrong offset!");
static_assert(offsetof(AMixedRealityCaptureActor, bAutoBroadcast) == 0x000333, "Member 'AMixedRealityCaptureActor::bAutoBroadcast' has a wrong offset!");
static_assert(offsetof(AMixedRealityCaptureActor, DebugVisualizerMesh) == 0x000360, "Member 'AMixedRealityCaptureActor::DebugVisualizerMesh' has a wrong offset!");

// Class MixedRealityCaptureFramework.MixedRealityCaptureComponent
// 0x0180 (0x09C0 - 0x0840)
class UMixedRealityCaptureComponent final : public USceneCaptureComponent2D
{
public:
	class UMediaPlayer*                           MediaSource;                                       // 0x0840(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     VideoProcessingMaterial;                           // 0x0848(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMrcVideoProcessingParams              VideoProcessingParams;                             // 0x0850(0x00A0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FMrcVideoCaptureFeedIndex              CaptureFeedRef;                                    // 0x08F0(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOpenCVLensDistortionParameters        LensDistortionParameters;                          // 0x0908(0x0034)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_93C[0x4];                                      // 0x093C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TrackingSourceName;                                // 0x0940(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 GarbageMatteCaptureTextureTarget;                  // 0x0948(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TrackingLatency;                                   // 0x0950(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoLoadConfiguration;                            // 0x0954(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_955[0x3];                                      // 0x0955(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProjectionDepthOffset;                             // 0x0958(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bProjectionDepthTracking;                          // 0x095C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_95D[0x3];                                      // 0x095D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnCaptureSourceOpened;                             // 0x0960(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UChildActorComponent*                   ProjectionActor;                                   // 0x0970(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMotionControllerComponent*             PairedTracker;                                     // 0x0978(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        TrackingOriginOffset;                              // 0x0980(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_988[0x8];                                      // 0x0988(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMrcGarbageMatteCaptureComponent*       GarbageMatteCaptureComponent;                      // 0x0990(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             DistortionDisplacementMap;                         // 0x0998(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9A0[0x20];                                     // 0x09A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyCalibrationData(class UMrcCalibrationData* ConfigData);
	void DetatchFromDevice();
	bool LoadConfiguration(const class FString& SlotName, int32 UserIndex);
	bool LoadDefaultConfiguration();
	void OnVideoFeedOpened(const struct FMrcVideoCaptureFeedIndex& FeedRef);
	bool SaveAsDefaultConfiguration_K2();
	bool SaveConfiguration_K2(const class FString& SlotName, int32 UserIndex);
	void SetCaptureDevice(const struct FMrcVideoCaptureFeedIndex& FeedRef);
	void SetDeviceAttachment(class FName SourceName);
	void SetEnableProjectionDepthTracking(bool bEnable);
	bool SetGarbageMatteActor(class AMrcGarbageMatteActor* Actor);
	void SetLensDistortionParameters(const struct FOpenCVLensDistortionParameters& ModelRef);
	void SetProjectionDepthOffset(float DepthOffset);
	void SetTrackingDelay(int32 DelayMS);
	void SetVidProcessingParams(const struct FMrcVideoProcessingParams& NewVidProcessingParams);
	void SetVidProjectionMat(class UMaterialInterface* NewMaterial);

	class UMrcCalibrationData* ConstructCalibrationData() const;
	void FillOutCalibrationData(class UMrcCalibrationData* Dst) const;
	class AActor* GetProjectionActor_K2() const;
	int32 GetTrackingDelay() const;
	bool IsTracked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MixedRealityCaptureComponent">();
	}
	static class UMixedRealityCaptureComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMixedRealityCaptureComponent>();
	}
};
static_assert(alignof(UMixedRealityCaptureComponent) == 0x000010, "Wrong alignment on UMixedRealityCaptureComponent");
static_assert(sizeof(UMixedRealityCaptureComponent) == 0x0009C0, "Wrong size on UMixedRealityCaptureComponent");
static_assert(offsetof(UMixedRealityCaptureComponent, MediaSource) == 0x000840, "Member 'UMixedRealityCaptureComponent::MediaSource' has a wrong offset!");
static_assert(offsetof(UMixedRealityCaptureComponent, VideoProcessingMaterial) == 0x000848, "Member 'UMixedRealityCaptureComponent::VideoProcessingMaterial' has a wrong offset!");
static_assert(offsetof(UMixedRealityCaptureComponent, VideoProcessingParams) == 0x000850, "Member 'UMixedRealityCaptureComponent::VideoProcessingParams' has a wrong offset!");
static_assert(offsetof(UMixedRealityCaptureComponent, CaptureFeedRef) == 0x0008F0, "Member 'UMixedRealityCaptureComponent::CaptureFeedRef' has a wrong offset!");
static_assert(offsetof(UMixedRealityCaptureComponent, LensDistortionParameters) == 0x000908, "Member 'UMixedRealityCaptureComponent::LensDistortionParameters' has a wrong offset!");
static_assert(offsetof(UMixedRealityCaptureComponent, TrackingSourceName) == 0x000940, "Member 'UMixedRealityCaptureComponent::TrackingSourceName' has a wrong offset!");
static_assert(offsetof(UMixedRealityCaptureComponent, GarbageMatteCaptureTextureTarget) == 0x000948, "Member 'UMixedRealityCaptureComponent::GarbageMatteCaptureTextureTarget' has a wrong offset!");
static_assert(offsetof(UMixedRealityCaptureComponent, TrackingLatency) == 0x000950, "Member 'UMixedRealityCaptureComponent::TrackingLatency' has a wrong offset!");
static_assert(offsetof(UMixedRealityCaptureComponent, bAutoLoadConfiguration) == 0x000954, "Member 'UMixedRealityCaptureComponent::bAutoLoadConfiguration' has a wrong offset!");
static_assert(offsetof(UMixedRealityCaptureComponent, ProjectionDepthOffset) == 0x000958, "Member 'UMixedRealityCaptureComponent::ProjectionDepthOffset' has a wrong offset!");
static_assert(offsetof(UMixedRealityCaptureComponent, bProjectionDepthTracking) == 0x00095C, "Member 'UMixedRealityCaptureComponent::bProjectionDepthTracking' has a wrong offset!");
static_assert(offsetof(UMixedRealityCaptureComponent, OnCaptureSourceOpened) == 0x000960, "Member 'UMixedRealityCaptureComponent::OnCaptureSourceOpened' has a wrong offset!");
static_assert(offsetof(UMixedRealityCaptureComponent, ProjectionActor) == 0x000970, "Member 'UMixedRealityCaptureComponent::ProjectionActor' has a wrong offset!");
static_assert(offsetof(UMixedRealityCaptureComponent, PairedTracker) == 0x000978, "Member 'UMixedRealityCaptureComponent::PairedTracker' has a wrong offset!");
static_assert(offsetof(UMixedRealityCaptureComponent, TrackingOriginOffset) == 0x000980, "Member 'UMixedRealityCaptureComponent::TrackingOriginOffset' has a wrong offset!");
static_assert(offsetof(UMixedRealityCaptureComponent, GarbageMatteCaptureComponent) == 0x000990, "Member 'UMixedRealityCaptureComponent::GarbageMatteCaptureComponent' has a wrong offset!");
static_assert(offsetof(UMixedRealityCaptureComponent, DistortionDisplacementMap) == 0x000998, "Member 'UMixedRealityCaptureComponent::DistortionDisplacementMap' has a wrong offset!");

// Class MixedRealityCaptureFramework.MrcCalibrationData
// 0x0130 (0x0158 - 0x0028)
class UMrcCalibrationData : public USaveGame
{
public:
	struct FMrcLensCalibrationData                LensData;                                          // 0x0028(0x0038)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FMrcAlignmentSaveData                  AlignmentData;                                     // 0x0060(0x0028)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FMrcGarbageMatteSaveData>       GarbageMatteSaveDatas;                             // 0x0088(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FMrcCompositingSaveData                CompositingData;                                   // 0x0098(0x00C0)(BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MrcCalibrationData">();
	}
	static class UMrcCalibrationData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMrcCalibrationData>();
	}
};
static_assert(alignof(UMrcCalibrationData) == 0x000008, "Wrong alignment on UMrcCalibrationData");
static_assert(sizeof(UMrcCalibrationData) == 0x000158, "Wrong size on UMrcCalibrationData");
static_assert(offsetof(UMrcCalibrationData, LensData) == 0x000028, "Member 'UMrcCalibrationData::LensData' has a wrong offset!");
static_assert(offsetof(UMrcCalibrationData, AlignmentData) == 0x000060, "Member 'UMrcCalibrationData::AlignmentData' has a wrong offset!");
static_assert(offsetof(UMrcCalibrationData, GarbageMatteSaveDatas) == 0x000088, "Member 'UMrcCalibrationData::GarbageMatteSaveDatas' has a wrong offset!");
static_assert(offsetof(UMrcCalibrationData, CompositingData) == 0x000098, "Member 'UMrcCalibrationData::CompositingData' has a wrong offset!");

// Class MixedRealityCaptureFramework.MrcCalibrationSaveGame
// 0x0018 (0x0170 - 0x0158)
class UMrcCalibrationSaveGame final : public UMrcCalibrationData
{
public:
	class FString                                 SaveSlotName;                                      // 0x0158(0x0010)(BlueprintVisible, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UserIndex;                                         // 0x0168(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConfigurationSaveVersion;                          // 0x016C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MrcCalibrationSaveGame">();
	}
	static class UMrcCalibrationSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMrcCalibrationSaveGame>();
	}
};
static_assert(alignof(UMrcCalibrationSaveGame) == 0x000008, "Wrong alignment on UMrcCalibrationSaveGame");
static_assert(sizeof(UMrcCalibrationSaveGame) == 0x000170, "Wrong size on UMrcCalibrationSaveGame");
static_assert(offsetof(UMrcCalibrationSaveGame, SaveSlotName) == 0x000158, "Member 'UMrcCalibrationSaveGame::SaveSlotName' has a wrong offset!");
static_assert(offsetof(UMrcCalibrationSaveGame, UserIndex) == 0x000168, "Member 'UMrcCalibrationSaveGame::UserIndex' has a wrong offset!");
static_assert(offsetof(UMrcCalibrationSaveGame, ConfigurationSaveVersion) == 0x00016C, "Member 'UMrcCalibrationSaveGame::ConfigurationSaveVersion' has a wrong offset!");

// Class MixedRealityCaptureFramework.MrcGarbageMatteActor
// 0x0020 (0x0348 - 0x0328)
class AMrcGarbageMatteActor final : public AActor
{
public:
	class UStaticMesh*                            GarbageMatteMesh;                                  // 0x0328(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterial*                              GarbageMatteMaterial;                              // 0x0330(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UPrimitiveComponent*>            GarbageMattes;                                     // 0x0338(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	class UPrimitiveComponent* AddNewGabageMatte(const struct FMrcGarbageMatteSaveData& GarbageMatteData);
	void ApplyCalibrationData(const TArray<struct FMrcGarbageMatteSaveData>& GarbageMatteData);
	class UPrimitiveComponent* CreateGarbageMatte(const struct FMrcGarbageMatteSaveData& GarbageMatteData);
	void GetGarbageMatteData(TArray<struct FMrcGarbageMatteSaveData>* GarbageMatteDataOut);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MrcGarbageMatteActor">();
	}
	static class AMrcGarbageMatteActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMrcGarbageMatteActor>();
	}
};
static_assert(alignof(AMrcGarbageMatteActor) == 0x000008, "Wrong alignment on AMrcGarbageMatteActor");
static_assert(sizeof(AMrcGarbageMatteActor) == 0x000348, "Wrong size on AMrcGarbageMatteActor");
static_assert(offsetof(AMrcGarbageMatteActor, GarbageMatteMesh) == 0x000328, "Member 'AMrcGarbageMatteActor::GarbageMatteMesh' has a wrong offset!");
static_assert(offsetof(AMrcGarbageMatteActor, GarbageMatteMaterial) == 0x000330, "Member 'AMrcGarbageMatteActor::GarbageMatteMaterial' has a wrong offset!");
static_assert(offsetof(AMrcGarbageMatteActor, GarbageMattes) == 0x000338, "Member 'AMrcGarbageMatteActor::GarbageMattes' has a wrong offset!");

// Class MixedRealityCaptureFramework.MixedRealityCaptureBillboard
// 0x0000 (0x0570 - 0x0570)
class UMixedRealityCaptureBillboard final : public UMaterialBillboardComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MixedRealityCaptureBillboard">();
	}
	static class UMixedRealityCaptureBillboard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMixedRealityCaptureBillboard>();
	}
};
static_assert(alignof(UMixedRealityCaptureBillboard) == 0x000008, "Wrong alignment on UMixedRealityCaptureBillboard");
static_assert(sizeof(UMixedRealityCaptureBillboard) == 0x000570, "Wrong size on UMixedRealityCaptureBillboard");

// Class MixedRealityCaptureFramework.MrcProjectionActor
// 0x0010 (0x0338 - 0x0328)
class AMrcProjectionActor final : public AActor
{
public:
	class UMixedRealityCaptureBillboard*          ProjectionComponent;                               // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class USceneComponent>         AttachTarget;                                      // 0x0330(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MrcProjectionActor">();
	}
	static class AMrcProjectionActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMrcProjectionActor>();
	}
};
static_assert(alignof(AMrcProjectionActor) == 0x000008, "Wrong alignment on AMrcProjectionActor");
static_assert(sizeof(AMrcProjectionActor) == 0x000338, "Wrong size on AMrcProjectionActor");
static_assert(offsetof(AMrcProjectionActor, ProjectionComponent) == 0x000328, "Member 'AMrcProjectionActor::ProjectionComponent' has a wrong offset!");
static_assert(offsetof(AMrcProjectionActor, AttachTarget) == 0x000330, "Member 'AMrcProjectionActor::AttachTarget' has a wrong offset!");

// Class MixedRealityCaptureFramework.MrcUtilLibrary
// 0x0000 (0x0028 - 0x0028)
class UMrcUtilLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UTexture* GetMixedRealityCaptureTexture();
	static bool IsMixedRealityCaptureBroadcasting();
	static void SetMixedRealityCaptureBroadcasting(bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MrcUtilLibrary">();
	}
	static class UMrcUtilLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMrcUtilLibrary>();
	}
};
static_assert(alignof(UMrcUtilLibrary) == 0x000008, "Wrong alignment on UMrcUtilLibrary");
static_assert(sizeof(UMrcUtilLibrary) == 0x000028, "Wrong size on UMrcUtilLibrary");

// Class MixedRealityCaptureFramework.AsyncTask_OpenMrcVidCaptureFeedBase
// 0x0040 (0x0070 - 0x0030)
class UAsyncTask_OpenMrcVidCaptureFeedBase : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFail;                                            // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UMediaPlayer*                           MediaPlayer;                                       // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0x18];                                      // 0x0058(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnVideoFeedOpened(const class FString& DeviceURL);
	void OnVideoFeedOpenFailure(const class FString& DeviceURL);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncTask_OpenMrcVidCaptureFeedBase">();
	}
	static class UAsyncTask_OpenMrcVidCaptureFeedBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncTask_OpenMrcVidCaptureFeedBase>();
	}
};
static_assert(alignof(UAsyncTask_OpenMrcVidCaptureFeedBase) == 0x000008, "Wrong alignment on UAsyncTask_OpenMrcVidCaptureFeedBase");
static_assert(sizeof(UAsyncTask_OpenMrcVidCaptureFeedBase) == 0x000070, "Wrong size on UAsyncTask_OpenMrcVidCaptureFeedBase");
static_assert(offsetof(UAsyncTask_OpenMrcVidCaptureFeedBase, OnSuccess) == 0x000030, "Member 'UAsyncTask_OpenMrcVidCaptureFeedBase::OnSuccess' has a wrong offset!");
static_assert(offsetof(UAsyncTask_OpenMrcVidCaptureFeedBase, OnFail) == 0x000040, "Member 'UAsyncTask_OpenMrcVidCaptureFeedBase::OnFail' has a wrong offset!");
static_assert(offsetof(UAsyncTask_OpenMrcVidCaptureFeedBase, MediaPlayer) == 0x000050, "Member 'UAsyncTask_OpenMrcVidCaptureFeedBase::MediaPlayer' has a wrong offset!");

// Class MixedRealityCaptureFramework.AsyncTask_OpenMrcVidCaptureDevice
// 0x0000 (0x0070 - 0x0070)
class UAsyncTask_OpenMrcVidCaptureDevice final : public UAsyncTask_OpenMrcVidCaptureFeedBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncTask_OpenMrcVidCaptureDevice">();
	}
	static class UAsyncTask_OpenMrcVidCaptureDevice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncTask_OpenMrcVidCaptureDevice>();
	}
};
static_assert(alignof(UAsyncTask_OpenMrcVidCaptureDevice) == 0x000008, "Wrong alignment on UAsyncTask_OpenMrcVidCaptureDevice");
static_assert(sizeof(UAsyncTask_OpenMrcVidCaptureDevice) == 0x000070, "Wrong size on UAsyncTask_OpenMrcVidCaptureDevice");

// Class MixedRealityCaptureFramework.AsyncTask_OpenMrcVidCaptureFeed
// 0x0018 (0x0088 - 0x0070)
class UAsyncTask_OpenMrcVidCaptureFeed final : public UAsyncTask_OpenMrcVidCaptureFeedBase
{
public:
	uint8                                         Pad_70[0x18];                                      // 0x0070(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncTask_OpenMrcVidCaptureFeed">();
	}
	static class UAsyncTask_OpenMrcVidCaptureFeed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncTask_OpenMrcVidCaptureFeed>();
	}
};
static_assert(alignof(UAsyncTask_OpenMrcVidCaptureFeed) == 0x000008, "Wrong alignment on UAsyncTask_OpenMrcVidCaptureFeed");
static_assert(sizeof(UAsyncTask_OpenMrcVidCaptureFeed) == 0x000088, "Wrong size on UAsyncTask_OpenMrcVidCaptureFeed");

}

