#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: SiliconRising

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "SiliconRising_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "PhysXVehicles_classes.hpp"


namespace SDK
{

// Class SiliconRising.ClipAnimInstance
// 0x0018 (0x0370 - 0x0358)
class UClipAnimInstance : public UAnimInstance
{
public:
	float                                         fAnimOffset;                                       // 0x0358(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35C[0x4];                                      // 0x035C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpaceBase*                        AnimOffset_Clip;                                   // 0x0360(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Anim_Idle;                                         // 0x0368(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClipAnimInstance">();
	}
	static class UClipAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClipAnimInstance>();
	}
};
static_assert(alignof(UClipAnimInstance) == 0x000008, "Wrong alignment on UClipAnimInstance");
static_assert(sizeof(UClipAnimInstance) == 0x000370, "Wrong size on UClipAnimInstance");
static_assert(offsetof(UClipAnimInstance, fAnimOffset) == 0x000358, "Member 'UClipAnimInstance::fAnimOffset' has a wrong offset!");
static_assert(offsetof(UClipAnimInstance, AnimOffset_Clip) == 0x000360, "Member 'UClipAnimInstance::AnimOffset_Clip' has a wrong offset!");
static_assert(offsetof(UClipAnimInstance, Anim_Idle) == 0x000368, "Member 'UClipAnimInstance::Anim_Idle' has a wrong offset!");

// Class SiliconRising.FlatBuffersYYMsgObjectPropertyVector2
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgObjectPropertyVector2 final : public UObject
{
public:
	static bool PackObjectPropertyVector2(class UObject* InWorldContextObject, const struct FYYMsgObjectPropertyVector2& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackObjectPropertyVector2(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgObjectPropertyVector2* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgObjectPropertyVector2">();
	}
	static class UFlatBuffersYYMsgObjectPropertyVector2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgObjectPropertyVector2>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgObjectPropertyVector2) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgObjectPropertyVector2");
static_assert(sizeof(UFlatBuffersYYMsgObjectPropertyVector2) == 0x000028, "Wrong size on UFlatBuffersYYMsgObjectPropertyVector2");

// Class SiliconRising.ASensitiveCharacter
// 0x0000 (0x0740 - 0x0740)
class AASensitiveCharacter : public ACharacter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASensitiveCharacter">();
	}
	static class AASensitiveCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AASensitiveCharacter>();
	}
};
static_assert(alignof(AASensitiveCharacter) == 0x000010, "Wrong alignment on AASensitiveCharacter");
static_assert(sizeof(AASensitiveCharacter) == 0x000740, "Wrong size on AASensitiveCharacter");

// Class SiliconRising.FlatBuffersYYMsgObjectRecordString
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgObjectRecordString final : public UObject
{
public:
	static bool PackObjectRecordString(class UObject* InWorldContextObject, const struct FYYMsgObjectRecordString& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackObjectRecordString(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgObjectRecordString* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgObjectRecordString">();
	}
	static class UFlatBuffersYYMsgObjectRecordString* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgObjectRecordString>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgObjectRecordString) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgObjectRecordString");
static_assert(sizeof(UFlatBuffersYYMsgObjectRecordString) == 0x000028, "Wrong size on UFlatBuffersYYMsgObjectRecordString");

// Class SiliconRising.BTT_MoveToBlackboardBase
// 0x0018 (0x00B8 - 0x00A0)
class UBTT_MoveToBlackboardBase : public UBTTask_BlueprintBase
{
public:
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindReceiveMoveCompleted(class AAIController* AI_Controller);
	void ReceiveMoveCompleted(EPathFollowingResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTT_MoveToBlackboardBase">();
	}
	static class UBTT_MoveToBlackboardBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTT_MoveToBlackboardBase>();
	}
};
static_assert(alignof(UBTT_MoveToBlackboardBase) == 0x000008, "Wrong alignment on UBTT_MoveToBlackboardBase");
static_assert(sizeof(UBTT_MoveToBlackboardBase) == 0x0000B8, "Wrong size on UBTT_MoveToBlackboardBase");

// Class SiliconRising.FlatBuffersYYMsgObjectRecordByte
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgObjectRecordByte final : public UObject
{
public:
	static bool PackObjectRecordByte(class UObject* InWorldContextObject, const struct FYYMsgObjectRecordByte& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackObjectRecordByte(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgObjectRecordByte* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgObjectRecordByte">();
	}
	static class UFlatBuffersYYMsgObjectRecordByte* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgObjectRecordByte>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgObjectRecordByte) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgObjectRecordByte");
static_assert(sizeof(UFlatBuffersYYMsgObjectRecordByte) == 0x000028, "Wrong size on UFlatBuffersYYMsgObjectRecordByte");

// Class SiliconRising.CharacterCamp
// 0x0018 (0x0108 - 0x00F0)
class UCharacterCamp final : public UActorComponent
{
public:
	EPawnCamp                                     MyCamp;                                            // 0x00F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanBeAttacked;                                     // 0x00F1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F2[0x6];                                       // 0x00F2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCampConfig>                    Config;                                            // 0x00F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterCamp">();
	}
	static class UCharacterCamp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterCamp>();
	}
};
static_assert(alignof(UCharacterCamp) == 0x000008, "Wrong alignment on UCharacterCamp");
static_assert(sizeof(UCharacterCamp) == 0x000108, "Wrong size on UCharacterCamp");
static_assert(offsetof(UCharacterCamp, MyCamp) == 0x0000F0, "Member 'UCharacterCamp::MyCamp' has a wrong offset!");
static_assert(offsetof(UCharacterCamp, CanBeAttacked) == 0x0000F1, "Member 'UCharacterCamp::CanBeAttacked' has a wrong offset!");
static_assert(offsetof(UCharacterCamp, Config) == 0x0000F8, "Member 'UCharacterCamp::Config' has a wrong offset!");

// Class SiliconRising.FlatBuffersYYMsgObjectRecordObject
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgObjectRecordObject final : public UObject
{
public:
	static bool PackObjectRecordObject(class UObject* InWorldContextObject, const struct FYYMsgObjectRecordObject& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackObjectRecordObject(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgObjectRecordObject* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgObjectRecordObject">();
	}
	static class UFlatBuffersYYMsgObjectRecordObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgObjectRecordObject>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgObjectRecordObject) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgObjectRecordObject");
static_assert(sizeof(UFlatBuffersYYMsgObjectRecordObject) == 0x000028, "Wrong size on UFlatBuffersYYMsgObjectRecordObject");

// Class SiliconRising.CharacterHandAnimInstance
// 0x0028 (0x0380 - 0x0358)
class UCharacterHandAnimInstance : public UAnimInstance
{
public:
	EItemTypes                                    eHoldWeaponType;                                   // 0x0358(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemTypes                                    eCarryWeaponClipType;                              // 0x0359(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHold;                                           // 0x035A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBothHand;                                       // 0x035B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPullBolt;                                       // 0x035C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemTypes                                    ePullBoltType;                                     // 0x035D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCarryClip;                                      // 0x035E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35F[0x1];                                      // 0x035F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                vHandLocationOffset;                               // 0x0360(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               rHandRotationOffset;                               // 0x036C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsPushClip;                                       // 0x0378(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_379[0x7];                                      // 0x0379(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterHandAnimInstance">();
	}
	static class UCharacterHandAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterHandAnimInstance>();
	}
};
static_assert(alignof(UCharacterHandAnimInstance) == 0x000008, "Wrong alignment on UCharacterHandAnimInstance");
static_assert(sizeof(UCharacterHandAnimInstance) == 0x000380, "Wrong size on UCharacterHandAnimInstance");
static_assert(offsetof(UCharacterHandAnimInstance, eHoldWeaponType) == 0x000358, "Member 'UCharacterHandAnimInstance::eHoldWeaponType' has a wrong offset!");
static_assert(offsetof(UCharacterHandAnimInstance, eCarryWeaponClipType) == 0x000359, "Member 'UCharacterHandAnimInstance::eCarryWeaponClipType' has a wrong offset!");
static_assert(offsetof(UCharacterHandAnimInstance, bIsHold) == 0x00035A, "Member 'UCharacterHandAnimInstance::bIsHold' has a wrong offset!");
static_assert(offsetof(UCharacterHandAnimInstance, bIsBothHand) == 0x00035B, "Member 'UCharacterHandAnimInstance::bIsBothHand' has a wrong offset!");
static_assert(offsetof(UCharacterHandAnimInstance, bIsPullBolt) == 0x00035C, "Member 'UCharacterHandAnimInstance::bIsPullBolt' has a wrong offset!");
static_assert(offsetof(UCharacterHandAnimInstance, ePullBoltType) == 0x00035D, "Member 'UCharacterHandAnimInstance::ePullBoltType' has a wrong offset!");
static_assert(offsetof(UCharacterHandAnimInstance, bIsCarryClip) == 0x00035E, "Member 'UCharacterHandAnimInstance::bIsCarryClip' has a wrong offset!");
static_assert(offsetof(UCharacterHandAnimInstance, vHandLocationOffset) == 0x000360, "Member 'UCharacterHandAnimInstance::vHandLocationOffset' has a wrong offset!");
static_assert(offsetof(UCharacterHandAnimInstance, rHandRotationOffset) == 0x00036C, "Member 'UCharacterHandAnimInstance::rHandRotationOffset' has a wrong offset!");
static_assert(offsetof(UCharacterHandAnimInstance, bIsPushClip) == 0x000378, "Member 'UCharacterHandAnimInstance::bIsPushClip' has a wrong offset!");

// Class SiliconRising.CommandLineParametersBPLibrary
// 0x0000 (0x0028 - 0x0028)
class UCommandLineParametersBPLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AppendToCommandLine(const class FString& argument);
	static bool CommandLineArgIntValue(const class FString& Key, int32* Value);
	static bool CommandLineArgPresent(const class FString& Key);
	static bool CommandLineArgValue(const class FString& Key, class FString* Value);
	static class FString GetFullCommandLine();
	static class FString GetOriginalCommandLine();
	static bool SetFullCommandLine(const class FString& Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandLineParametersBPLibrary">();
	}
	static class UCommandLineParametersBPLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandLineParametersBPLibrary>();
	}
};
static_assert(alignof(UCommandLineParametersBPLibrary) == 0x000008, "Wrong alignment on UCommandLineParametersBPLibrary");
static_assert(sizeof(UCommandLineParametersBPLibrary) == 0x000028, "Wrong size on UCommandLineParametersBPLibrary");

// Class SiliconRising.CryptBPLibrary
// 0x0000 (0x0028 - 0x0028)
class UCryptBPLibrary final : public UBlueprintFunctionLibrary
{
public:
	static TArray<uint8> AES_CBC_DecryptBytesArray(const TArray<uint8>& BytesArray, const TArray<uint8>& InitiationVector);
	static class FString AES_CBC_DecryptBytesArrayToString(const TArray<uint8>& BytesArray, const TArray<uint8>& InitiationVector);
	static TArray<uint8> AES_CBC_EncryptBytesArray(const TArray<uint8>& BytesArray, const TArray<uint8>& InitiationVector);
	static TArray<uint8> AES_CBC_EncryptStringToBytesArray(const class FString& String, const TArray<uint8>& InitiationVector);
	static TArray<uint8> AES_CTR_BytesArray(const TArray<uint8>& BytesArray, const TArray<uint8>& InitiationVector);
	static class FString AES_CTR_String(const class FString& String, const TArray<uint8>& InitiationVector);
	static TArray<uint8> AES_ECB_DecryptBytesArray(const TArray<uint8>& BytesArray);
	static class FString AES_ECB_DecryptBytesArrayToString(const TArray<uint8>& BytesArray);
	static TArray<uint8> AES_ECB_EncryptBytesArray(const TArray<uint8>& BytesArray);
	static TArray<uint8> AES_ECB_EncryptStringToBytesArray(const class FString& String);
	static TArray<uint8> Base64DecodeFromBytesArrayToBytesArray(const TArray<uint8>& BytesArray);
	static class FString Base64DecodeFromBytesArrayToString(const TArray<uint8>& BytesArray);
	static TArray<uint8> Base64DecodeFromStringToBytesArray(const class FString& Source);
	static class FString Base64DecodeFromStringToString(const class FString& Source);
	static class FString Base64EncodeFromBytesArray(const TArray<uint8>& BytesArray);
	static class FString Base64EncodeFromString(const class FString& Source);
	static int32 BinToDec(const class FString& BinaryString);
	static TArray<uint8> CaesarDecryptBytesArray(const TArray<uint8>& BytesArray);
	static class FString CaesarDecryptString(const class FString& String);
	static TArray<uint8> CaesarEncryptBytesArray(const TArray<uint8>& BytesArray);
	static class FString CaesarEncryptString(const class FString& String);
	static class FString ConvertBytesToString(const TArray<uint8>& Bytes);
	static TArray<uint8> ConvertStringToBytes(const class FString& String);
	static class FString DecToBin(int32 Integer);
	static class FString DecToHex(int32 Integer);
	static int32 HexToDec(const class FString& HexadecimalString);
	static void InitializeKeysByte(const uint8 CaesarKey, const TArray<uint8>& XORKey, const TArray<uint8>& AESKey);
	static void InitializeKeysString(const uint8 CaesarKey, const class FString& XORKey, const class FString& AESKey);
	static class FString PKCS7Padding(const class FString& Source);
	static TArray<uint8> PKCS7PaddingForArray(const TArray<uint8>& Source);
	static class FString PKCS7Unpadding(const class FString& Source);
	static TArray<uint8> PKCS7UnpaddingForArray(const TArray<uint8>& Source);
	static class FString RSADecrypt(const class FString& Key, const class FString& Content, bool bPublic);
	static TArray<uint8> RSADecryptForArray(const class FString& Key, const TArray<uint8>& Content, bool bPublic);
	static class FString RSAEncrypt(const class FString& Key, const class FString& Content, bool bPublic);
	static TArray<uint8> RSAEncryptForArray(const class FString& Key, const TArray<uint8>& Content, bool bPublic);
	static TArray<uint8> XORBytesArray(const TArray<uint8>& BytesArray);
	static class FString XORString(const class FString& String);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CryptBPLibrary">();
	}
	static class UCryptBPLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCryptBPLibrary>();
	}
};
static_assert(alignof(UCryptBPLibrary) == 0x000008, "Wrong alignment on UCryptBPLibrary");
static_assert(sizeof(UCryptBPLibrary) == 0x000028, "Wrong size on UCryptBPLibrary");

// Class SiliconRising.HttpUtilities
// 0x0128 (0x0450 - 0x0328)
class AHttpUtilities : public AActor
{
public:
	uint8                                         Pad_328[0x48];                                     // 0x0328(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 strChannelID;                                      // 0x0370(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 strGameID;                                         // 0x0380(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPrintDebug;                                      // 0x0390(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_391[0x17];                                     // 0x0391(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StringResponse;                                    // 0x03A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StringResponseErrno;                               // 0x03B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLeaderBoardData>               ListLeaderBoard;                                   // 0x03C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSteamUserData>                 ListSteamUserData;                                 // 0x03D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FPlayerTopInfo                         PlayerTopInfo;                                     // 0x03E8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 pageID;                                            // 0x0438(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         totalPage;                                         // 0x0448(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         currentPage;                                       // 0x044C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class FString GetCurrentLanguage();
	void GetJsonFromUrl(const class FString& URL, const TDelegate<void(bool Success)>& Callback);
	void GetLeaderBoardData(const class FString& URL, const TArray<class FString>& Data, const TDelegate<void(bool Success)>& Callback);
	TArray<struct FLeaderBoardData> GetListLeaderBoard();
	class FString GetPageID();
	struct FPlayerTopInfo GetPlayerTopInfo();
	void GetSteamUserHeadUrl(const class FString& URL, const TDelegate<void(bool Success)>& Callback);
	class FString GetStringErrorNumber();
	class FString GetStringFromJson(const class FString& JsonKey);
	class FString GetStringFromJsonFields(const TArray<class FString>& JsonField, const class FString& JsonKey, bool* isOK);
	class FString GetStringResponse();
	void Login(const class FString& URL, const TMap<class FString, class FString>& ExtraData, const TDelegate<void(bool Success)>& Callback);
	void PostUrl(const class FString& URL, const class FString& Data, const TDelegate<void(bool Success)>& Callback);
	void SendScore(const class FString& URL, const TArray<class FString>& Data, const TDelegate<void(bool Success)>& Callback);
	void VerifyGame(const class FString& URL, const TMap<class FString, class FString>& ExtraData, const TDelegate<void(bool Success)>& Callback);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HttpUtilities">();
	}
	static class AHttpUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHttpUtilities>();
	}
};
static_assert(alignof(AHttpUtilities) == 0x000008, "Wrong alignment on AHttpUtilities");
static_assert(sizeof(AHttpUtilities) == 0x000450, "Wrong size on AHttpUtilities");
static_assert(offsetof(AHttpUtilities, strChannelID) == 0x000370, "Member 'AHttpUtilities::strChannelID' has a wrong offset!");
static_assert(offsetof(AHttpUtilities, strGameID) == 0x000380, "Member 'AHttpUtilities::strGameID' has a wrong offset!");
static_assert(offsetof(AHttpUtilities, IsPrintDebug) == 0x000390, "Member 'AHttpUtilities::IsPrintDebug' has a wrong offset!");
static_assert(offsetof(AHttpUtilities, StringResponse) == 0x0003A8, "Member 'AHttpUtilities::StringResponse' has a wrong offset!");
static_assert(offsetof(AHttpUtilities, StringResponseErrno) == 0x0003B8, "Member 'AHttpUtilities::StringResponseErrno' has a wrong offset!");
static_assert(offsetof(AHttpUtilities, ListLeaderBoard) == 0x0003C8, "Member 'AHttpUtilities::ListLeaderBoard' has a wrong offset!");
static_assert(offsetof(AHttpUtilities, ListSteamUserData) == 0x0003D8, "Member 'AHttpUtilities::ListSteamUserData' has a wrong offset!");
static_assert(offsetof(AHttpUtilities, PlayerTopInfo) == 0x0003E8, "Member 'AHttpUtilities::PlayerTopInfo' has a wrong offset!");
static_assert(offsetof(AHttpUtilities, pageID) == 0x000438, "Member 'AHttpUtilities::pageID' has a wrong offset!");
static_assert(offsetof(AHttpUtilities, totalPage) == 0x000448, "Member 'AHttpUtilities::totalPage' has a wrong offset!");
static_assert(offsetof(AHttpUtilities, currentPage) == 0x00044C, "Member 'AHttpUtilities::currentPage' has a wrong offset!");

// Class SiliconRising.Mer2GameInstanceBase
// 0x0010 (0x00B0 - 0x00A0)
class UMer2GameInstanceBase : public UGameInstance
{
public:
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Mer2GameInstanceBase">();
	}
	static class UMer2GameInstanceBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMer2GameInstanceBase>();
	}
};
static_assert(alignof(UMer2GameInstanceBase) == 0x000008, "Wrong alignment on UMer2GameInstanceBase");
static_assert(sizeof(UMer2GameInstanceBase) == 0x0000B0, "Wrong size on UMer2GameInstanceBase");

// Class SiliconRising.Mer2WheeldVehicle
// 0x0010 (0x0398 - 0x0388)
class AMer2WheeldVehicle : public APawn
{
public:
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0388(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWheeledVehicleMovementComponent*       VehicleMovement;                                   // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Mer2WheeldVehicle">();
	}
	static class AMer2WheeldVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMer2WheeldVehicle>();
	}
};
static_assert(alignof(AMer2WheeldVehicle) == 0x000008, "Wrong alignment on AMer2WheeldVehicle");
static_assert(sizeof(AMer2WheeldVehicle) == 0x000398, "Wrong size on AMer2WheeldVehicle");
static_assert(offsetof(AMer2WheeldVehicle, Mesh) == 0x000388, "Member 'AMer2WheeldVehicle::Mesh' has a wrong offset!");
static_assert(offsetof(AMer2WheeldVehicle, VehicleMovement) == 0x000390, "Member 'AMer2WheeldVehicle::VehicleMovement' has a wrong offset!");

// Class SiliconRising.Mer2WheeledVehicleMovement4W
// 0x0000 (0x0428 - 0x0428)
class UMer2WheeledVehicleMovement4W final : public UWheeledVehicleMovementComponent4W
{
public:
	float GetEngineMaxRPM();
	float GetFinalSteeringInput();
	void SetEngineMaxRPM(float fRPM);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Mer2WheeledVehicleMovement4W">();
	}
	static class UMer2WheeledVehicleMovement4W* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMer2WheeledVehicleMovement4W>();
	}
};
static_assert(alignof(UMer2WheeledVehicleMovement4W) == 0x000008, "Wrong alignment on UMer2WheeledVehicleMovement4W");
static_assert(sizeof(UMer2WheeledVehicleMovement4W) == 0x000428, "Wrong size on UMer2WheeledVehicleMovement4W");

// Class SiliconRising.Mer2_PVP_PlayerController
// 0x0008 (0x0680 - 0x0678)
class AMer2_PVP_PlayerController : public APlayerController
{
public:
	bool                                          IsNeedDestroyPawnWhileLeavingGame;                 // 0x0678(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_679[0x7];                                      // 0x0679(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Mer2_PVP_PlayerController">();
	}
	static class AMer2_PVP_PlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMer2_PVP_PlayerController>();
	}
};
static_assert(alignof(AMer2_PVP_PlayerController) == 0x000008, "Wrong alignment on AMer2_PVP_PlayerController");
static_assert(sizeof(AMer2_PVP_PlayerController) == 0x000680, "Wrong size on AMer2_PVP_PlayerController");
static_assert(offsetof(AMer2_PVP_PlayerController, IsNeedDestroyPawnWhileLeavingGame) == 0x000678, "Member 'AMer2_PVP_PlayerController::IsNeedDestroyPawnWhileLeavingGame' has a wrong offset!");

// Class SiliconRising.Mercenary2GameMode
// 0x0000 (0x03C8 - 0x03C8)
class AMercenary2GameMode final : public AGameModeBase
{
public:
	bool VerifyUserInfo(const class FString& strToken);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Mercenary2GameMode">();
	}
	static class AMercenary2GameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMercenary2GameMode>();
	}
};
static_assert(alignof(AMercenary2GameMode) == 0x000008, "Wrong alignment on AMercenary2GameMode");
static_assert(sizeof(AMercenary2GameMode) == 0x0003C8, "Wrong size on AMercenary2GameMode");

// Class SiliconRising.Mercenary2_PVP_GameMode
// 0x0010 (0x03D8 - 0x03C8)
class AMercenary2_PVP_GameMode : public AGameModeBase
{
public:
	uint8                                         Pad_3C8[0x10];                                     // 0x03C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Evt_NewPlayerConnect(class APlayerController* NewPlayerController, const class FString& RoomName, const class FString& RoomID, const class FString& PlayerID);
	void ShutdownServer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Mercenary2_PVP_GameMode">();
	}
	static class AMercenary2_PVP_GameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMercenary2_PVP_GameMode>();
	}
};
static_assert(alignof(AMercenary2_PVP_GameMode) == 0x000008, "Wrong alignment on AMercenary2_PVP_GameMode");
static_assert(sizeof(AMercenary2_PVP_GameMode) == 0x0003D8, "Wrong size on AMercenary2_PVP_GameMode");

// Class SiliconRising.ProjectileBase
// 0x0000 (0x0328 - 0x0328)
class AProjectileBase final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileBase">();
	}
	static class AProjectileBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectileBase>();
	}
};
static_assert(alignof(AProjectileBase) == 0x000008, "Wrong alignment on AProjectileBase");
static_assert(sizeof(AProjectileBase) == 0x000328, "Wrong size on AProjectileBase");

// Class SiliconRising.TcpSocketConnection
// 0x0040 (0x0368 - 0x0328)
class ATcpSocketConnection : public AActor
{
public:
	int32                                         SendBufferSize;                                    // 0x0328(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReceiveBufferSize;                                 // 0x032C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeBetweenTicks;                                  // 0x0330(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_334[0x34];                                     // 0x0334(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static TArray<uint8> Concat_BytesBytes(const TArray<uint8>& A, const TArray<uint8>& B);
	static TArray<uint8> Conv_ByteToBytes(uint8 InByte);
	static TArray<uint8> Conv_FloatToBytes(float InFloat);
	static TArray<uint8> Conv_IntToBytes(int32 inInt);
	static TArray<uint8> Conv_StringToBytes(const class FString& InStr);
	static uint8 Message_ReadByte(TArray<uint8>& Message);
	static float Message_ReadFloat(TArray<uint8>& Message);
	static int32 Message_ReadInt(TArray<uint8>& Message);
	static class FString Message_ReadString(TArray<uint8>& Message, int32 StringLength);

	void Connect(const class FString& ipAddress, int32 Port, const TDelegate<void(const class FString& ConnectionId)>& OnDisconnected, const TDelegate<void(const class FString& ConnectionId)>& OnConnected, const TDelegate<void(const class FString& ConnectionId, const TArray<uint8>& Message)>& OnMessageReceived, class FString* ConnectionId, bool bUniqueCheck, bool* bIsAlreadyConnected);
	void Disconnect(const class FString& ConnectionId);
	void DisconnectAll();
	bool SendData(const class FString& ConnectionId, const TArray<uint8>& DataToSend);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TcpSocketConnection">();
	}
	static class ATcpSocketConnection* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATcpSocketConnection>();
	}
};
static_assert(alignof(ATcpSocketConnection) == 0x000008, "Wrong alignment on ATcpSocketConnection");
static_assert(sizeof(ATcpSocketConnection) == 0x000368, "Wrong size on ATcpSocketConnection");
static_assert(offsetof(ATcpSocketConnection, SendBufferSize) == 0x000328, "Member 'ATcpSocketConnection::SendBufferSize' has a wrong offset!");
static_assert(offsetof(ATcpSocketConnection, ReceiveBufferSize) == 0x00032C, "Member 'ATcpSocketConnection::ReceiveBufferSize' has a wrong offset!");
static_assert(offsetof(ATcpSocketConnection, TimeBetweenTicks) == 0x000330, "Member 'ATcpSocketConnection::TimeBetweenTicks' has a wrong offset!");

// Class SiliconRising.TcpPvpNetBaseActor
// 0x00D8 (0x0440 - 0x0368)
class ATcpPvpNetBaseActor : public ATcpSocketConnection
{
public:
	class FString                                 Client_Private_Key;                                // 0x0368(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Server_Public_Key;                                 // 0x0378(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ServerIP;                                          // 0x0388(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ServerPort;                                        // 0x0398(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39C[0xA4];                                     // 0x039C(0x00A4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnConnected(const class FString& ConnectionId);
	void OnDisconnect(const class FString& ConnectionId);
	void OnGameInstanceShutdown();
	void OnReceivedMessage(const class FString& ConnectionId, const TArray<uint8>& Message);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TcpPvpNetBaseActor">();
	}
	static class ATcpPvpNetBaseActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATcpPvpNetBaseActor>();
	}
};
static_assert(alignof(ATcpPvpNetBaseActor) == 0x000008, "Wrong alignment on ATcpPvpNetBaseActor");
static_assert(sizeof(ATcpPvpNetBaseActor) == 0x000440, "Wrong size on ATcpPvpNetBaseActor");
static_assert(offsetof(ATcpPvpNetBaseActor, Client_Private_Key) == 0x000368, "Member 'ATcpPvpNetBaseActor::Client_Private_Key' has a wrong offset!");
static_assert(offsetof(ATcpPvpNetBaseActor, Server_Public_Key) == 0x000378, "Member 'ATcpPvpNetBaseActor::Server_Public_Key' has a wrong offset!");
static_assert(offsetof(ATcpPvpNetBaseActor, ServerIP) == 0x000388, "Member 'ATcpPvpNetBaseActor::ServerIP' has a wrong offset!");
static_assert(offsetof(ATcpPvpNetBaseActor, ServerPort) == 0x000398, "Member 'ATcpPvpNetBaseActor::ServerPort' has a wrong offset!");

// Class SiliconRising.TcpPvpClientToBackendServer
// 0x0018 (0x0458 - 0x0440)
class ATcpPvpClientToBackendServer : public ATcpPvpNetBaseActor
{
public:
	uint8                                         Pad_440[0x18];                                     // 0x0440(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckConnection();
	void ClearCurrentRoomInfo();
	void Evt_OnConnected();
	void Evt_OnDisconnect();
	void Evt_ReceiveMessage(const struct FYYMsgData& Message);
	struct FYYMsgIdent GetCurrentPlayerID();
	struct FYYMsgReqAckRoomInfo GetCurrentRoomInfo();
	void MsgID_MID_ACK_PINGPONG(const class FString& ConnectionId, int32 MsgID, const TArray<uint8>& Data);
	void OnRecieveAllMessage(const class FString& ConnectionId, int32 MsgID, const TArray<uint8>& Data);
	bool SendMessageToServer(const struct FYYMsgData& Message);
	void SetCurrentPlayerID(const struct FYYMsgIdent& Value);
	void SetCurrentRoomInfo(const struct FYYMsgReqAckRoomInfo& Value);
	bool StartConnectToServer(bool bUniqueCheck, bool* bIsAlreadyConnected);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TcpPvpClientToBackendServer">();
	}
	static class ATcpPvpClientToBackendServer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATcpPvpClientToBackendServer>();
	}
};
static_assert(alignof(ATcpPvpClientToBackendServer) == 0x000008, "Wrong alignment on ATcpPvpClientToBackendServer");
static_assert(sizeof(ATcpPvpClientToBackendServer) == 0x000458, "Wrong size on ATcpPvpClientToBackendServer");

// Class SiliconRising.TcpPvpServerToBackendServer
// 0x0018 (0x0458 - 0x0440)
class ATcpPvpServerToBackendServer : public ATcpPvpNetBaseActor
{
public:
	uint8                                         Pad_440[0x18];                                     // 0x0440(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Evt_OnConnected();
	void Evt_OnDisconnect();
	void Evt_ReceiveMessage(const struct FYYMsgData& Message);
	int32 GetServerRunPort();
	void MsgID_MID_ACK_PINGPONG(const class FString& ConnectionId, int32 MsgID, const TArray<uint8>& Data);
	void OnRecieveAllMessage(const class FString& ConnectionId, int32 MsgID, const TArray<uint8>& Data);
	bool SendMessageToServer(const struct FYYMsgData& Message);
	bool StartConnectToServer(bool bUniqueCheck, bool* bIsAlreadyConnected);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TcpPvpServerToBackendServer">();
	}
	static class ATcpPvpServerToBackendServer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATcpPvpServerToBackendServer>();
	}
};
static_assert(alignof(ATcpPvpServerToBackendServer) == 0x000008, "Wrong alignment on ATcpPvpServerToBackendServer");
static_assert(sizeof(ATcpPvpServerToBackendServer) == 0x000458, "Wrong size on ATcpPvpServerToBackendServer");

// Class SiliconRising.TcpSocketSettings
// 0x0008 (0x0030 - 0x0028)
class UTcpSocketSettings final : public UObject
{
public:
	bool                                          bPostErrorsToMessageLog;                           // 0x0028(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TcpSocketSettings">();
	}
	static class UTcpSocketSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTcpSocketSettings>();
	}
};
static_assert(alignof(UTcpSocketSettings) == 0x000008, "Wrong alignment on UTcpSocketSettings");
static_assert(sizeof(UTcpSocketSettings) == 0x000030, "Wrong size on UTcpSocketSettings");
static_assert(offsetof(UTcpSocketSettings, bPostErrorsToMessageLog) == 0x000028, "Member 'UTcpSocketSettings::bPostErrorsToMessageLog' has a wrong offset!");

// Class SiliconRising.UtilityBPLibrary
// 0x0000 (0x0028 - 0x0028)
class UUtilityBPLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FYYMsgInt64 Add_FYYMsgInt64FYYMsgInt64(const struct FYYMsgInt64& A, const struct FYYMsgInt64& B);
	static bool ChangeCurrentLevelToListen(class UObject* WorldContextObject);
	static class FString DecryptString(const class FString& String);
	static class FString DecryptStringKey(const class FString& String, const class FString& Key);
	static struct FYYMsgInt64 Divide_FYYMsgInt64FYYMsgInt64(const struct FYYMsgInt64& A, const struct FYYMsgInt64& B);
	static class FString EncryptString(const class FString& String);
	static class FString EncryptStringKey(const class FString& String, const class FString& Key);
	static bool EqualEqual_FYYMsgInt64FYYMsgInt64(const struct FYYMsgInt64& A, const struct FYYMsgInt64& B);
	static int32 GameBuildNumber();
	static int32 GameMajorNumber();
	static int32 GameMinorNumber();
	static int32 GamePatchNumber();
	static class FString GameVersionString();
	static class FString GetBuildMode();
	static class FString GetChannelID();
	static class FString GetCurrentWorldType();
	static class FString GetHMDMonitorName();
	static EVRHeadMountedDevicType_Mer2 GetHMDType();
	static class FString GetHostByName(const class FString& hostname);
	static class FString GetMachineID();
	static class FString GetPVPServerIP();
	static bool GetSteamAchievementsFromIni(TArray<struct FOnlineAchievementSteam>* OutArray);
	static class FString GetViveportHeadUrl();
	static class FString GetViveportID();
	static class FString GetViveportNickName();
	static int32 GetVRControllerDeviceID();
	static void GetVRDevicePropertyString(EVRDeviceProperty_String PropertyToRetrieve, int32 DeviceID, class FString* StringValue, EBPOVRResultSwitch* Result);
	static bool Greater_FYYMsgInt64FYYMsgInt64(const struct FYYMsgInt64& A, const struct FYYMsgInt64& B);
	static bool GreaterEqual_FYYMsgInt64FYYMsgInt64(const struct FYYMsgInt64& A, const struct FYYMsgInt64& B);
	static class FString Int64ToString(const struct FYYMsgInt64& Value);
	static bool IsDevelopmentMode();
	static bool IsPlayInEditor();
	static bool Less_FYYMsgInt64FYYMsgInt64(const struct FYYMsgInt64& A, const struct FYYMsgInt64& B);
	static bool LessEqual_FYYMsgInt64FYYMsgInt64(const struct FYYMsgInt64& A, const struct FYYMsgInt64& B);
	static struct FYYMsgInt64 Multiply_FYYMsgInt64FYYMsgInt64(const struct FYYMsgInt64& A, const struct FYYMsgInt64& B);
	static bool NotEqual_FYYMsgInt64FYYMsgInt64(const struct FYYMsgInt64& A, const struct FYYMsgInt64& B);
	static struct FYYMsgInt64 Percent_FYYMsgInt64FYYMsgInt64(const struct FYYMsgInt64& A, const struct FYYMsgInt64& B);
	static void SetPlanarReflectionScreenPercentage(class UPlanarReflectionComponent* PlanarReflectionComponent, int32 nPercentage);
	static void SetPVPServerIP(const class FString& Value);
	static void SetViveportHeadUrl(const class FString& Value);
	static void SetViveportID(const class FString& Value);
	static void SetViveportIsGetUserData(bool Value);
	static void SetViveportNickName(const class FString& Value);
	static void SetViveportPassword(const class FString& Value);
	static void SortArrayWithDefault(const TArray<class UObject*>& inArray, TArray<class UObject*>* OutArray);
	static struct FYYMsgInt64 StringToInt64(const class FString& Value);
	static struct FYYMsgInt64 Subtract_FYYMsgInt64FYYMsgInt64(const struct FYYMsgInt64& A, const struct FYYMsgInt64& B);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityBPLibrary">();
	}
	static class UUtilityBPLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityBPLibrary>();
	}
};
static_assert(alignof(UUtilityBPLibrary) == 0x000008, "Wrong alignment on UUtilityBPLibrary");
static_assert(sizeof(UUtilityBPLibrary) == 0x000028, "Wrong size on UUtilityBPLibrary");

// Class SiliconRising.ViveportSDK
// 0x0040 (0x0368 - 0x0328)
class AViveportSDK : public AActor
{
public:
	uint8                                         Pad_328[0x40];                                     // 0x0328(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetIsDRMCheckOK();
	bool GetIsSDKCheckOK();
	void StartViveportSDK();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ViveportSDK">();
	}
	static class AViveportSDK* GetDefaultObj()
	{
		return GetDefaultObjImpl<AViveportSDK>();
	}
};
static_assert(alignof(AViveportSDK) == 0x000008, "Wrong alignment on AViveportSDK");
static_assert(sizeof(AViveportSDK) == 0x000368, "Wrong size on AViveportSDK");

// Class SiliconRising.WeaponAnimInstance
// 0x00B8 (0x0410 - 0x0358)
class UWeaponAnimInstance : public UAnimInstance
{
public:
	bool                                          bTriggerFire;                                      // 0x0358(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerReload;                                    // 0x0359(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerClipEmpty;                                 // 0x035A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPullTrigger;                                      // 0x035B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         fWaitTimer;                                        // 0x035C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         fReloadTime;                                       // 0x0360(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         fMaxReloadTime;                                    // 0x0364(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPullBolt;                                         // 0x0368(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_369[0x3];                                      // 0x0369(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         fPullBoltLength;                                   // 0x036C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         fPullBoltLengthMax;                                // 0x0370(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerContinuously;                              // 0x0374(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAnimOffset_BoltValid;                           // 0x0375(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUseEmptyBoltPosition;                           // 0x0376(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_377[0x1];                                      // 0x0377(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                vEjectLocation;                                    // 0x0378(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSetEjectLocation;                               // 0x0384(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_385[0x3];                                      // 0x0385(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoltName;                                          // 0x0388(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EjectName;                                         // 0x0390(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        AnimOffset_Bolt;                                   // 0x0398(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Anim_ClipEmpty;                                    // 0x03A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Anim_Idle;                                         // 0x03A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Anim_Firing;                                       // 0x03B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Anim_Hold;                                         // 0x03B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Anim_Reload1;                                      // 0x03C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Anim_Reload2;                                      // 0x03C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Anim_Reload3;                                      // 0x03D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D8[0x38];                                     // 0x03D8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeAnimState(EWState CurState, bool NewValue);
	struct FVector GetBoltCurrentOffset();
	struct FTransform GetBoltCurrentTransform();
	struct FTransform GetBoltInitTransform();
	void SetBoltInitTransform(const struct FTransform& InitTransform);
	void UpdateReloadDelay(float fDelta);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponAnimInstance">();
	}
	static class UWeaponAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponAnimInstance>();
	}
};
static_assert(alignof(UWeaponAnimInstance) == 0x000008, "Wrong alignment on UWeaponAnimInstance");
static_assert(sizeof(UWeaponAnimInstance) == 0x000410, "Wrong size on UWeaponAnimInstance");
static_assert(offsetof(UWeaponAnimInstance, bTriggerFire) == 0x000358, "Member 'UWeaponAnimInstance::bTriggerFire' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInstance, bTriggerReload) == 0x000359, "Member 'UWeaponAnimInstance::bTriggerReload' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInstance, bTriggerClipEmpty) == 0x00035A, "Member 'UWeaponAnimInstance::bTriggerClipEmpty' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInstance, bPullTrigger) == 0x00035B, "Member 'UWeaponAnimInstance::bPullTrigger' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInstance, fWaitTimer) == 0x00035C, "Member 'UWeaponAnimInstance::fWaitTimer' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInstance, fReloadTime) == 0x000360, "Member 'UWeaponAnimInstance::fReloadTime' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInstance, fMaxReloadTime) == 0x000364, "Member 'UWeaponAnimInstance::fMaxReloadTime' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInstance, bPullBolt) == 0x000368, "Member 'UWeaponAnimInstance::bPullBolt' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInstance, fPullBoltLength) == 0x00036C, "Member 'UWeaponAnimInstance::fPullBoltLength' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInstance, fPullBoltLengthMax) == 0x000370, "Member 'UWeaponAnimInstance::fPullBoltLengthMax' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInstance, bTriggerContinuously) == 0x000374, "Member 'UWeaponAnimInstance::bTriggerContinuously' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInstance, bIsAnimOffset_BoltValid) == 0x000375, "Member 'UWeaponAnimInstance::bIsAnimOffset_BoltValid' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInstance, bIsUseEmptyBoltPosition) == 0x000376, "Member 'UWeaponAnimInstance::bIsUseEmptyBoltPosition' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInstance, vEjectLocation) == 0x000378, "Member 'UWeaponAnimInstance::vEjectLocation' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInstance, bIsSetEjectLocation) == 0x000384, "Member 'UWeaponAnimInstance::bIsSetEjectLocation' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInstance, BoltName) == 0x000388, "Member 'UWeaponAnimInstance::BoltName' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInstance, EjectName) == 0x000390, "Member 'UWeaponAnimInstance::EjectName' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInstance, AnimOffset_Bolt) == 0x000398, "Member 'UWeaponAnimInstance::AnimOffset_Bolt' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInstance, Anim_ClipEmpty) == 0x0003A0, "Member 'UWeaponAnimInstance::Anim_ClipEmpty' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInstance, Anim_Idle) == 0x0003A8, "Member 'UWeaponAnimInstance::Anim_Idle' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInstance, Anim_Firing) == 0x0003B0, "Member 'UWeaponAnimInstance::Anim_Firing' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInstance, Anim_Hold) == 0x0003B8, "Member 'UWeaponAnimInstance::Anim_Hold' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInstance, Anim_Reload1) == 0x0003C0, "Member 'UWeaponAnimInstance::Anim_Reload1' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInstance, Anim_Reload2) == 0x0003C8, "Member 'UWeaponAnimInstance::Anim_Reload2' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInstance, Anim_Reload3) == 0x0003D0, "Member 'UWeaponAnimInstance::Anim_Reload3' has a wrong offset!");

// Class SiliconRising.WeaponBase
// 0x0000 (0x0328 - 0x0328)
class AWeaponBase final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponBase">();
	}
	static class AWeaponBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWeaponBase>();
	}
};
static_assert(alignof(AWeaponBase) == 0x000008, "Wrong alignment on AWeaponBase");
static_assert(sizeof(AWeaponBase) == 0x000328, "Wrong size on AWeaponBase");

// Class SiliconRising.WinnerAnimInstance
// 0x0008 (0x0360 - 0x0358)
class UWinnerAnimInstance final : public UAnimInstance
{
public:
	bool                                          bShowWinAnim;                                      // 0x0358(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_359[0x7];                                      // 0x0359(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WinnerAnimInstance">();
	}
	static class UWinnerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWinnerAnimInstance>();
	}
};
static_assert(alignof(UWinnerAnimInstance) == 0x000008, "Wrong alignment on UWinnerAnimInstance");
static_assert(sizeof(UWinnerAnimInstance) == 0x000360, "Wrong size on UWinnerAnimInstance");
static_assert(offsetof(UWinnerAnimInstance, bShowWinAnim) == 0x000358, "Member 'UWinnerAnimInstance::bShowWinAnim' has a wrong offset!");

// Class SiliconRising.FlatBuffersYYMsgIdent
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgIdent final : public UObject
{
public:
	static bool PackIdent(class UObject* InWorldContextObject, const struct FYYMsgIdent& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackIdent(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgIdent* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgIdent">();
	}
	static class UFlatBuffersYYMsgIdent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgIdent>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgIdent) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgIdent");
static_assert(sizeof(UFlatBuffersYYMsgIdent) == 0x000028, "Wrong size on UFlatBuffersYYMsgIdent");

// Class SiliconRising.FlatBuffersYYMsgVector2
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgVector2 final : public UObject
{
public:
	static bool PackVector2(class UObject* InWorldContextObject, const struct FYYMsgVector2& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackVector2(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgVector2* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgVector2">();
	}
	static class UFlatBuffersYYMsgVector2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgVector2>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgVector2) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgVector2");
static_assert(sizeof(UFlatBuffersYYMsgVector2) == 0x000028, "Wrong size on UFlatBuffersYYMsgVector2");

// Class SiliconRising.FlatBuffersYYMsgVector3
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgVector3 final : public UObject
{
public:
	static bool PackVector3(class UObject* InWorldContextObject, const struct FYYMsgVector3& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackVector3(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgVector3* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgVector3">();
	}
	static class UFlatBuffersYYMsgVector3* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgVector3>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgVector3) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgVector3");
static_assert(sizeof(UFlatBuffersYYMsgVector3) == 0x000028, "Wrong size on UFlatBuffersYYMsgVector3");

// Class SiliconRising.FlatBuffersYYMsgVector4
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgVector4 final : public UObject
{
public:
	static bool PackVector4(class UObject* InWorldContextObject, const struct FYYMsgVector4& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackVector4(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgVector4* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgVector4">();
	}
	static class UFlatBuffersYYMsgVector4* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgVector4>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgVector4) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgVector4");
static_assert(sizeof(UFlatBuffersYYMsgVector4) == 0x000028, "Wrong size on UFlatBuffersYYMsgVector4");

// Class SiliconRising.FlatBuffersYYMsgPropertyInt
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgPropertyInt final : public UObject
{
public:
	static bool PackPropertyInt(class UObject* InWorldContextObject, const struct FYYMsgPropertyInt& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackPropertyInt(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgPropertyInt* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgPropertyInt">();
	}
	static class UFlatBuffersYYMsgPropertyInt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgPropertyInt>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgPropertyInt) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgPropertyInt");
static_assert(sizeof(UFlatBuffersYYMsgPropertyInt) == 0x000028, "Wrong size on UFlatBuffersYYMsgPropertyInt");

// Class SiliconRising.FlatBuffersYYMsgPropertyFloat
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgPropertyFloat final : public UObject
{
public:
	static bool PackPropertyFloat(class UObject* InWorldContextObject, const struct FYYMsgPropertyFloat& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackPropertyFloat(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgPropertyFloat* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgPropertyFloat">();
	}
	static class UFlatBuffersYYMsgPropertyFloat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgPropertyFloat>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgPropertyFloat) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgPropertyFloat");
static_assert(sizeof(UFlatBuffersYYMsgPropertyFloat) == 0x000028, "Wrong size on UFlatBuffersYYMsgPropertyFloat");

// Class SiliconRising.FlatBuffersYYMsgPropertyString
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgPropertyString final : public UObject
{
public:
	static bool PackPropertyString(class UObject* InWorldContextObject, const struct FYYMsgPropertyString& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackPropertyString(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgPropertyString* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgPropertyString">();
	}
	static class UFlatBuffersYYMsgPropertyString* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgPropertyString>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgPropertyString) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgPropertyString");
static_assert(sizeof(UFlatBuffersYYMsgPropertyString) == 0x000028, "Wrong size on UFlatBuffersYYMsgPropertyString");

// Class SiliconRising.FlatBuffersYYMsgPropertyByte
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgPropertyByte final : public UObject
{
public:
	static bool PackPropertyByte(class UObject* InWorldContextObject, const struct FYYMsgPropertyByte& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackPropertyByte(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgPropertyByte* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgPropertyByte">();
	}
	static class UFlatBuffersYYMsgPropertyByte* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgPropertyByte>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgPropertyByte) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgPropertyByte");
static_assert(sizeof(UFlatBuffersYYMsgPropertyByte) == 0x000028, "Wrong size on UFlatBuffersYYMsgPropertyByte");

// Class SiliconRising.FlatBuffersYYMsgPropertyObject
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgPropertyObject final : public UObject
{
public:
	static bool PackPropertyObject(class UObject* InWorldContextObject, const struct FYYMsgPropertyObject& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackPropertyObject(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgPropertyObject* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgPropertyObject">();
	}
	static class UFlatBuffersYYMsgPropertyObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgPropertyObject>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgPropertyObject) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgPropertyObject");
static_assert(sizeof(UFlatBuffersYYMsgPropertyObject) == 0x000028, "Wrong size on UFlatBuffersYYMsgPropertyObject");

// Class SiliconRising.FlatBuffersYYMsgPropertyVector2
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgPropertyVector2 final : public UObject
{
public:
	static bool PackPropertyVector2(class UObject* InWorldContextObject, const struct FYYMsgPropertyVector2& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackPropertyVector2(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgPropertyVector2* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgPropertyVector2">();
	}
	static class UFlatBuffersYYMsgPropertyVector2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgPropertyVector2>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgPropertyVector2) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgPropertyVector2");
static_assert(sizeof(UFlatBuffersYYMsgPropertyVector2) == 0x000028, "Wrong size on UFlatBuffersYYMsgPropertyVector2");

// Class SiliconRising.FlatBuffersYYMsgPropertyVector3
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgPropertyVector3 final : public UObject
{
public:
	static bool PackPropertyVector3(class UObject* InWorldContextObject, const struct FYYMsgPropertyVector3& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackPropertyVector3(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgPropertyVector3* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgPropertyVector3">();
	}
	static class UFlatBuffersYYMsgPropertyVector3* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgPropertyVector3>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgPropertyVector3) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgPropertyVector3");
static_assert(sizeof(UFlatBuffersYYMsgPropertyVector3) == 0x000028, "Wrong size on UFlatBuffersYYMsgPropertyVector3");

// Class SiliconRising.FlatBuffersYYMsgPropertyVector4
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgPropertyVector4 final : public UObject
{
public:
	static bool PackPropertyVector4(class UObject* InWorldContextObject, const struct FYYMsgPropertyVector4& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackPropertyVector4(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgPropertyVector4* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgPropertyVector4">();
	}
	static class UFlatBuffersYYMsgPropertyVector4* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgPropertyVector4>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgPropertyVector4) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgPropertyVector4");
static_assert(sizeof(UFlatBuffersYYMsgPropertyVector4) == 0x000028, "Wrong size on UFlatBuffersYYMsgPropertyVector4");

// Class SiliconRising.FlatBuffersYYMsgRecordInt
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgRecordInt final : public UObject
{
public:
	static bool PackRecordInt(class UObject* InWorldContextObject, const struct FYYMsgRecordInt& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackRecordInt(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgRecordInt* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgRecordInt">();
	}
	static class UFlatBuffersYYMsgRecordInt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgRecordInt>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgRecordInt) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgRecordInt");
static_assert(sizeof(UFlatBuffersYYMsgRecordInt) == 0x000028, "Wrong size on UFlatBuffersYYMsgRecordInt");

// Class SiliconRising.FlatBuffersYYMsgRecordFloat
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgRecordFloat final : public UObject
{
public:
	static bool PackRecordFloat(class UObject* InWorldContextObject, const struct FYYMsgRecordFloat& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackRecordFloat(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgRecordFloat* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgRecordFloat">();
	}
	static class UFlatBuffersYYMsgRecordFloat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgRecordFloat>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgRecordFloat) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgRecordFloat");
static_assert(sizeof(UFlatBuffersYYMsgRecordFloat) == 0x000028, "Wrong size on UFlatBuffersYYMsgRecordFloat");

// Class SiliconRising.FlatBuffersYYMsgRecordString
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgRecordString final : public UObject
{
public:
	static bool PackRecordString(class UObject* InWorldContextObject, const struct FYYMsgRecordString& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackRecordString(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgRecordString* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgRecordString">();
	}
	static class UFlatBuffersYYMsgRecordString* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgRecordString>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgRecordString) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgRecordString");
static_assert(sizeof(UFlatBuffersYYMsgRecordString) == 0x000028, "Wrong size on UFlatBuffersYYMsgRecordString");

// Class SiliconRising.FlatBuffersYYMsgRecordByte
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgRecordByte final : public UObject
{
public:
	static bool PackRecordByte(class UObject* InWorldContextObject, const struct FYYMsgRecordByte& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackRecordByte(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgRecordByte* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgRecordByte">();
	}
	static class UFlatBuffersYYMsgRecordByte* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgRecordByte>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgRecordByte) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgRecordByte");
static_assert(sizeof(UFlatBuffersYYMsgRecordByte) == 0x000028, "Wrong size on UFlatBuffersYYMsgRecordByte");

// Class SiliconRising.FlatBuffersYYMsgRecordObject
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgRecordObject final : public UObject
{
public:
	static bool PackRecordObject(class UObject* InWorldContextObject, const struct FYYMsgRecordObject& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackRecordObject(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgRecordObject* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgRecordObject">();
	}
	static class UFlatBuffersYYMsgRecordObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgRecordObject>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgRecordObject) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgRecordObject");
static_assert(sizeof(UFlatBuffersYYMsgRecordObject) == 0x000028, "Wrong size on UFlatBuffersYYMsgRecordObject");

// Class SiliconRising.FlatBuffersYYMsgRecordVector2
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgRecordVector2 final : public UObject
{
public:
	static bool PackRecordVector2(class UObject* InWorldContextObject, const struct FYYMsgRecordVector2& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackRecordVector2(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgRecordVector2* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgRecordVector2">();
	}
	static class UFlatBuffersYYMsgRecordVector2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgRecordVector2>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgRecordVector2) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgRecordVector2");
static_assert(sizeof(UFlatBuffersYYMsgRecordVector2) == 0x000028, "Wrong size on UFlatBuffersYYMsgRecordVector2");

// Class SiliconRising.FlatBuffersYYMsgRecordVector3
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgRecordVector3 final : public UObject
{
public:
	static bool PackRecordVector3(class UObject* InWorldContextObject, const struct FYYMsgRecordVector3& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackRecordVector3(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgRecordVector3* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgRecordVector3">();
	}
	static class UFlatBuffersYYMsgRecordVector3* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgRecordVector3>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgRecordVector3) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgRecordVector3");
static_assert(sizeof(UFlatBuffersYYMsgRecordVector3) == 0x000028, "Wrong size on UFlatBuffersYYMsgRecordVector3");

// Class SiliconRising.FlatBuffersYYMsgRecordVector4
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgRecordVector4 final : public UObject
{
public:
	static bool PackRecordVector4(class UObject* InWorldContextObject, const struct FYYMsgRecordVector4& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackRecordVector4(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgRecordVector4* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgRecordVector4">();
	}
	static class UFlatBuffersYYMsgRecordVector4* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgRecordVector4>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgRecordVector4) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgRecordVector4");
static_assert(sizeof(UFlatBuffersYYMsgRecordVector4) == 0x000028, "Wrong size on UFlatBuffersYYMsgRecordVector4");

// Class SiliconRising.FlatBuffersYYMsgRecordAddRowStruct
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgRecordAddRowStruct final : public UObject
{
public:
	static bool PackRecordAddRowStruct(class UObject* InWorldContextObject, const struct FYYMsgRecordAddRowStruct& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackRecordAddRowStruct(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgRecordAddRowStruct* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgRecordAddRowStruct">();
	}
	static class UFlatBuffersYYMsgRecordAddRowStruct* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgRecordAddRowStruct>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgRecordAddRowStruct) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgRecordAddRowStruct");
static_assert(sizeof(UFlatBuffersYYMsgRecordAddRowStruct) == 0x000028, "Wrong size on UFlatBuffersYYMsgRecordAddRowStruct");

// Class SiliconRising.FlatBuffersYYMsgObjectRecordBase
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgObjectRecordBase final : public UObject
{
public:
	static bool PackObjectRecordBase(class UObject* InWorldContextObject, const struct FYYMsgObjectRecordBase& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackObjectRecordBase(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgObjectRecordBase* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgObjectRecordBase">();
	}
	static class UFlatBuffersYYMsgObjectRecordBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgObjectRecordBase>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgObjectRecordBase) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgObjectRecordBase");
static_assert(sizeof(UFlatBuffersYYMsgObjectRecordBase) == 0x000028, "Wrong size on UFlatBuffersYYMsgObjectRecordBase");

// Class SiliconRising.FlatBuffersYYMsgObjectPropertyList
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgObjectPropertyList final : public UObject
{
public:
	static bool PackObjectPropertyList(class UObject* InWorldContextObject, const struct FYYMsgObjectPropertyList& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackObjectPropertyList(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgObjectPropertyList* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgObjectPropertyList">();
	}
	static class UFlatBuffersYYMsgObjectPropertyList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgObjectPropertyList>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgObjectPropertyList) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgObjectPropertyList");
static_assert(sizeof(UFlatBuffersYYMsgObjectPropertyList) == 0x000028, "Wrong size on UFlatBuffersYYMsgObjectPropertyList");

// Class SiliconRising.FlatBuffersYYMsgMultiObjectPropertyList
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgMultiObjectPropertyList final : public UObject
{
public:
	static bool PackMultiObjectPropertyList(class UObject* InWorldContextObject, const struct FYYMsgMultiObjectPropertyList& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackMultiObjectPropertyList(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgMultiObjectPropertyList* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgMultiObjectPropertyList">();
	}
	static class UFlatBuffersYYMsgMultiObjectPropertyList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgMultiObjectPropertyList>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgMultiObjectPropertyList) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgMultiObjectPropertyList");
static_assert(sizeof(UFlatBuffersYYMsgMultiObjectPropertyList) == 0x000028, "Wrong size on UFlatBuffersYYMsgMultiObjectPropertyList");

// Class SiliconRising.FlatBuffersYYMsgObjectRecordList
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgObjectRecordList final : public UObject
{
public:
	static bool PackObjectRecordList(class UObject* InWorldContextObject, const struct FYYMsgObjectRecordList& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackObjectRecordList(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgObjectRecordList* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgObjectRecordList">();
	}
	static class UFlatBuffersYYMsgObjectRecordList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgObjectRecordList>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgObjectRecordList) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgObjectRecordList");
static_assert(sizeof(UFlatBuffersYYMsgObjectRecordList) == 0x000028, "Wrong size on UFlatBuffersYYMsgObjectRecordList");

// Class SiliconRising.FlatBuffersYYMsgMultiObjectRecordList
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgMultiObjectRecordList final : public UObject
{
public:
	static bool PackMultiObjectRecordList(class UObject* InWorldContextObject, const struct FYYMsgMultiObjectRecordList& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackMultiObjectRecordList(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgMultiObjectRecordList* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgMultiObjectRecordList">();
	}
	static class UFlatBuffersYYMsgMultiObjectRecordList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgMultiObjectRecordList>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgMultiObjectRecordList) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgMultiObjectRecordList");
static_assert(sizeof(UFlatBuffersYYMsgMultiObjectRecordList) == 0x000028, "Wrong size on UFlatBuffersYYMsgMultiObjectRecordList");

// Class SiliconRising.FlatBuffersYYMsgObjectPropertyInt
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgObjectPropertyInt final : public UObject
{
public:
	static bool PackObjectPropertyInt(class UObject* InWorldContextObject, const struct FYYMsgObjectPropertyInt& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackObjectPropertyInt(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgObjectPropertyInt* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgObjectPropertyInt">();
	}
	static class UFlatBuffersYYMsgObjectPropertyInt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgObjectPropertyInt>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgObjectPropertyInt) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgObjectPropertyInt");
static_assert(sizeof(UFlatBuffersYYMsgObjectPropertyInt) == 0x000028, "Wrong size on UFlatBuffersYYMsgObjectPropertyInt");

// Class SiliconRising.FlatBuffersYYMsgObjectPropertyFloat
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgObjectPropertyFloat final : public UObject
{
public:
	static bool PackObjectPropertyFloat(class UObject* InWorldContextObject, const struct FYYMsgObjectPropertyFloat& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackObjectPropertyFloat(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgObjectPropertyFloat* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgObjectPropertyFloat">();
	}
	static class UFlatBuffersYYMsgObjectPropertyFloat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgObjectPropertyFloat>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgObjectPropertyFloat) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgObjectPropertyFloat");
static_assert(sizeof(UFlatBuffersYYMsgObjectPropertyFloat) == 0x000028, "Wrong size on UFlatBuffersYYMsgObjectPropertyFloat");

// Class SiliconRising.FlatBuffersYYMsgObjectPropertyString
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgObjectPropertyString final : public UObject
{
public:
	static bool PackObjectPropertyString(class UObject* InWorldContextObject, const struct FYYMsgObjectPropertyString& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackObjectPropertyString(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgObjectPropertyString* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgObjectPropertyString">();
	}
	static class UFlatBuffersYYMsgObjectPropertyString* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgObjectPropertyString>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgObjectPropertyString) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgObjectPropertyString");
static_assert(sizeof(UFlatBuffersYYMsgObjectPropertyString) == 0x000028, "Wrong size on UFlatBuffersYYMsgObjectPropertyString");

// Class SiliconRising.FlatBuffersYYMsgObjectPropertyByte
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgObjectPropertyByte final : public UObject
{
public:
	static bool PackObjectPropertyByte(class UObject* InWorldContextObject, const struct FYYMsgObjectPropertyByte& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackObjectPropertyByte(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgObjectPropertyByte* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgObjectPropertyByte">();
	}
	static class UFlatBuffersYYMsgObjectPropertyByte* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgObjectPropertyByte>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgObjectPropertyByte) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgObjectPropertyByte");
static_assert(sizeof(UFlatBuffersYYMsgObjectPropertyByte) == 0x000028, "Wrong size on UFlatBuffersYYMsgObjectPropertyByte");

// Class SiliconRising.FlatBuffersYYMsgObjectPropertyObject
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgObjectPropertyObject final : public UObject
{
public:
	static bool PackObjectPropertyObject(class UObject* InWorldContextObject, const struct FYYMsgObjectPropertyObject& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackObjectPropertyObject(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgObjectPropertyObject* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgObjectPropertyObject">();
	}
	static class UFlatBuffersYYMsgObjectPropertyObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgObjectPropertyObject>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgObjectPropertyObject) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgObjectPropertyObject");
static_assert(sizeof(UFlatBuffersYYMsgObjectPropertyObject) == 0x000028, "Wrong size on UFlatBuffersYYMsgObjectPropertyObject");

// Class SiliconRising.FlatBuffersYYMsgObjectPropertyVector3
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgObjectPropertyVector3 final : public UObject
{
public:
	static bool PackObjectPropertyVector3(class UObject* InWorldContextObject, const struct FYYMsgObjectPropertyVector3& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackObjectPropertyVector3(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgObjectPropertyVector3* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgObjectPropertyVector3">();
	}
	static class UFlatBuffersYYMsgObjectPropertyVector3* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgObjectPropertyVector3>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgObjectPropertyVector3) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgObjectPropertyVector3");
static_assert(sizeof(UFlatBuffersYYMsgObjectPropertyVector3) == 0x000028, "Wrong size on UFlatBuffersYYMsgObjectPropertyVector3");

// Class SiliconRising.FlatBuffersYYMsgObjectPropertyVector4
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgObjectPropertyVector4 final : public UObject
{
public:
	static bool PackObjectPropertyVector4(class UObject* InWorldContextObject, const struct FYYMsgObjectPropertyVector4& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackObjectPropertyVector4(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgObjectPropertyVector4* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgObjectPropertyVector4">();
	}
	static class UFlatBuffersYYMsgObjectPropertyVector4* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgObjectPropertyVector4>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgObjectPropertyVector4) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgObjectPropertyVector4");
static_assert(sizeof(UFlatBuffersYYMsgObjectPropertyVector4) == 0x000028, "Wrong size on UFlatBuffersYYMsgObjectPropertyVector4");

// Class SiliconRising.FlatBuffersYYMsgObjectRecordInt
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgObjectRecordInt final : public UObject
{
public:
	static bool PackObjectRecordInt(class UObject* InWorldContextObject, const struct FYYMsgObjectRecordInt& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackObjectRecordInt(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgObjectRecordInt* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgObjectRecordInt">();
	}
	static class UFlatBuffersYYMsgObjectRecordInt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgObjectRecordInt>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgObjectRecordInt) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgObjectRecordInt");
static_assert(sizeof(UFlatBuffersYYMsgObjectRecordInt) == 0x000028, "Wrong size on UFlatBuffersYYMsgObjectRecordInt");

// Class SiliconRising.FlatBuffersYYMsgObjectRecordFloat
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgObjectRecordFloat final : public UObject
{
public:
	static bool PackObjectRecordFloat(class UObject* InWorldContextObject, const struct FYYMsgObjectRecordFloat& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackObjectRecordFloat(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgObjectRecordFloat* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgObjectRecordFloat">();
	}
	static class UFlatBuffersYYMsgObjectRecordFloat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgObjectRecordFloat>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgObjectRecordFloat) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgObjectRecordFloat");
static_assert(sizeof(UFlatBuffersYYMsgObjectRecordFloat) == 0x000028, "Wrong size on UFlatBuffersYYMsgObjectRecordFloat");

// Class SiliconRising.FlatBuffersYYMsgObjectRecordVector2
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgObjectRecordVector2 final : public UObject
{
public:
	static bool PackObjectRecordVector2(class UObject* InWorldContextObject, const struct FYYMsgObjectRecordVector2& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackObjectRecordVector2(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgObjectRecordVector2* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgObjectRecordVector2">();
	}
	static class UFlatBuffersYYMsgObjectRecordVector2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgObjectRecordVector2>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgObjectRecordVector2) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgObjectRecordVector2");
static_assert(sizeof(UFlatBuffersYYMsgObjectRecordVector2) == 0x000028, "Wrong size on UFlatBuffersYYMsgObjectRecordVector2");

// Class SiliconRising.FlatBuffersYYMsgObjectRecordVector3
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgObjectRecordVector3 final : public UObject
{
public:
	static bool PackObjectRecordVector3(class UObject* InWorldContextObject, const struct FYYMsgObjectRecordVector3& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackObjectRecordVector3(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgObjectRecordVector3* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgObjectRecordVector3">();
	}
	static class UFlatBuffersYYMsgObjectRecordVector3* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgObjectRecordVector3>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgObjectRecordVector3) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgObjectRecordVector3");
static_assert(sizeof(UFlatBuffersYYMsgObjectRecordVector3) == 0x000028, "Wrong size on UFlatBuffersYYMsgObjectRecordVector3");

// Class SiliconRising.FlatBuffersYYMsgObjectRecordVector4
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgObjectRecordVector4 final : public UObject
{
public:
	static bool PackObjectRecordVector4(class UObject* InWorldContextObject, const struct FYYMsgObjectRecordVector4& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackObjectRecordVector4(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgObjectRecordVector4* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgObjectRecordVector4">();
	}
	static class UFlatBuffersYYMsgObjectRecordVector4* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgObjectRecordVector4>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgObjectRecordVector4) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgObjectRecordVector4");
static_assert(sizeof(UFlatBuffersYYMsgObjectRecordVector4) == 0x000028, "Wrong size on UFlatBuffersYYMsgObjectRecordVector4");

// Class SiliconRising.FlatBuffersYYMsgObjectRecordSwap
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgObjectRecordSwap final : public UObject
{
public:
	static bool PackObjectRecordSwap(class UObject* InWorldContextObject, const struct FYYMsgObjectRecordSwap& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackObjectRecordSwap(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgObjectRecordSwap* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgObjectRecordSwap">();
	}
	static class UFlatBuffersYYMsgObjectRecordSwap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgObjectRecordSwap>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgObjectRecordSwap) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgObjectRecordSwap");
static_assert(sizeof(UFlatBuffersYYMsgObjectRecordSwap) == 0x000028, "Wrong size on UFlatBuffersYYMsgObjectRecordSwap");

// Class SiliconRising.FlatBuffersYYMsgObjectRecordAddRow
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgObjectRecordAddRow final : public UObject
{
public:
	static bool PackObjectRecordAddRow(class UObject* InWorldContextObject, const struct FYYMsgObjectRecordAddRow& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackObjectRecordAddRow(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgObjectRecordAddRow* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgObjectRecordAddRow">();
	}
	static class UFlatBuffersYYMsgObjectRecordAddRow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgObjectRecordAddRow>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgObjectRecordAddRow) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgObjectRecordAddRow");
static_assert(sizeof(UFlatBuffersYYMsgObjectRecordAddRow) == 0x000028, "Wrong size on UFlatBuffersYYMsgObjectRecordAddRow");

// Class SiliconRising.FlatBuffersYYMsgObjectRecordRemove
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgObjectRecordRemove final : public UObject
{
public:
	static bool PackObjectRecordRemove(class UObject* InWorldContextObject, const struct FYYMsgObjectRecordRemove& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackObjectRecordRemove(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgObjectRecordRemove* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgObjectRecordRemove">();
	}
	static class UFlatBuffersYYMsgObjectRecordRemove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgObjectRecordRemove>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgObjectRecordRemove) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgObjectRecordRemove");
static_assert(sizeof(UFlatBuffersYYMsgObjectRecordRemove) == 0x000028, "Wrong size on UFlatBuffersYYMsgObjectRecordRemove");

// Class SiliconRising.FlatBuffersYYMsgObjectRecordCleared
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgObjectRecordCleared final : public UObject
{
public:
	static bool PackObjectRecordCleared(class UObject* InWorldContextObject, const struct FYYMsgObjectRecordCleared& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackObjectRecordCleared(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgObjectRecordCleared* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgObjectRecordCleared">();
	}
	static class UFlatBuffersYYMsgObjectRecordCleared* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgObjectRecordCleared>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgObjectRecordCleared) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgObjectRecordCleared");
static_assert(sizeof(UFlatBuffersYYMsgObjectRecordCleared) == 0x000028, "Wrong size on UFlatBuffersYYMsgObjectRecordCleared");

// Class SiliconRising.FlatBuffersYYMsgPlayerPropertyBase
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgPlayerPropertyBase final : public UObject
{
public:
	static bool PackPlayerPropertyBase(class UObject* InWorldContextObject, const struct FYYMsgPlayerPropertyBase& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackPlayerPropertyBase(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgPlayerPropertyBase* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgPlayerPropertyBase">();
	}
	static class UFlatBuffersYYMsgPlayerPropertyBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgPlayerPropertyBase>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgPlayerPropertyBase) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgPlayerPropertyBase");
static_assert(sizeof(UFlatBuffersYYMsgPlayerPropertyBase) == 0x000028, "Wrong size on UFlatBuffersYYMsgPlayerPropertyBase");

// Class SiliconRising.FlatBuffersYYMsgPlayerRecordBase
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgPlayerRecordBase final : public UObject
{
public:
	static bool PackPlayerRecordBase(class UObject* InWorldContextObject, const struct FYYMsgPlayerRecordBase& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackPlayerRecordBase(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgPlayerRecordBase* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgPlayerRecordBase">();
	}
	static class UFlatBuffersYYMsgPlayerRecordBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgPlayerRecordBase>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgPlayerRecordBase) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgPlayerRecordBase");
static_assert(sizeof(UFlatBuffersYYMsgPlayerRecordBase) == 0x000028, "Wrong size on UFlatBuffersYYMsgPlayerRecordBase");

// Class SiliconRising.FlatBuffersYYMsgPlayerRecordList
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgPlayerRecordList final : public UObject
{
public:
	static bool PackPlayerRecordList(class UObject* InWorldContextObject, const struct FYYMsgPlayerRecordList& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackPlayerRecordList(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgPlayerRecordList* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgPlayerRecordList">();
	}
	static class UFlatBuffersYYMsgPlayerRecordList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgPlayerRecordList>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgPlayerRecordList) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgPlayerRecordList");
static_assert(sizeof(UFlatBuffersYYMsgPlayerRecordList) == 0x000028, "Wrong size on UFlatBuffersYYMsgPlayerRecordList");

// Class SiliconRising.FlatBuffersYYMsgMsgBase
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgMsgBase final : public UObject
{
public:
	static bool PackMsgBase(class UObject* InWorldContextObject, const struct FYYMsgMsgBase& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackMsgBase(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgMsgBase* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgMsgBase">();
	}
	static class UFlatBuffersYYMsgMsgBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgMsgBase>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgMsgBase) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgMsgBase");
static_assert(sizeof(UFlatBuffersYYMsgMsgBase) == 0x000028, "Wrong size on UFlatBuffersYYMsgMsgBase");

// Class SiliconRising.FlatBuffersYYMsgPackSURLParam
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgPackSURLParam final : public UObject
{
public:
	static bool PackPackSURLParam(class UObject* InWorldContextObject, const struct FYYMsgPackSURLParam& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackPackSURLParam(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgPackSURLParam* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgPackSURLParam">();
	}
	static class UFlatBuffersYYMsgPackSURLParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgPackSURLParam>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgPackSURLParam) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgPackSURLParam");
static_assert(sizeof(UFlatBuffersYYMsgPackSURLParam) == 0x000028, "Wrong size on UFlatBuffersYYMsgPackSURLParam");

// Class SiliconRising.FlatBuffersYYMsgReqAckPingPong
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgReqAckPingPong final : public UObject
{
public:
	static bool PackReqAckPingPong(class UObject* InWorldContextObject, const struct FYYMsgReqAckPingPong& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackReqAckPingPong(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgReqAckPingPong* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgReqAckPingPong">();
	}
	static class UFlatBuffersYYMsgReqAckPingPong* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgReqAckPingPong>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgReqAckPingPong) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgReqAckPingPong");
static_assert(sizeof(UFlatBuffersYYMsgReqAckPingPong) == 0x000028, "Wrong size on UFlatBuffersYYMsgReqAckPingPong");

// Class SiliconRising.FlatBuffersYYMsgReqAckLogin
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgReqAckLogin final : public UObject
{
public:
	static bool PackReqAckLogin(class UObject* InWorldContextObject, const struct FYYMsgReqAckLogin& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackReqAckLogin(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgReqAckLogin* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgReqAckLogin">();
	}
	static class UFlatBuffersYYMsgReqAckLogin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgReqAckLogin>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgReqAckLogin) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgReqAckLogin");
static_assert(sizeof(UFlatBuffersYYMsgReqAckLogin) == 0x000028, "Wrong size on UFlatBuffersYYMsgReqAckLogin");

// Class SiliconRising.FlatBuffersYYMsgReqStartMatch
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgReqStartMatch final : public UObject
{
public:
	static bool PackReqStartMatch(class UObject* InWorldContextObject, const struct FYYMsgReqStartMatch& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackReqStartMatch(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgReqStartMatch* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgReqStartMatch">();
	}
	static class UFlatBuffersYYMsgReqStartMatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgReqStartMatch>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgReqStartMatch) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgReqStartMatch");
static_assert(sizeof(UFlatBuffersYYMsgReqStartMatch) == 0x000028, "Wrong size on UFlatBuffersYYMsgReqStartMatch");

// Class SiliconRising.FlatBuffersYYMsgRoomCampMember
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgRoomCampMember final : public UObject
{
public:
	static bool PackRoomCampMember(class UObject* InWorldContextObject, const struct FYYMsgRoomCampMember& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackRoomCampMember(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgRoomCampMember* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgRoomCampMember">();
	}
	static class UFlatBuffersYYMsgRoomCampMember* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgRoomCampMember>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgRoomCampMember) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgRoomCampMember");
static_assert(sizeof(UFlatBuffersYYMsgRoomCampMember) == 0x000028, "Wrong size on UFlatBuffersYYMsgRoomCampMember");

// Class SiliconRising.FlatBuffersYYMsgRoomCamp
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgRoomCamp final : public UObject
{
public:
	static bool PackRoomCamp(class UObject* InWorldContextObject, const struct FYYMsgRoomCamp& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackRoomCamp(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgRoomCamp* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgRoomCamp">();
	}
	static class UFlatBuffersYYMsgRoomCamp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgRoomCamp>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgRoomCamp) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgRoomCamp");
static_assert(sizeof(UFlatBuffersYYMsgRoomCamp) == 0x000028, "Wrong size on UFlatBuffersYYMsgRoomCamp");

// Class SiliconRising.FlatBuffersYYMsgAckStartMatch
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgAckStartMatch final : public UObject
{
public:
	static bool PackAckStartMatch(class UObject* InWorldContextObject, const struct FYYMsgAckStartMatch& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackAckStartMatch(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgAckStartMatch* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgAckStartMatch">();
	}
	static class UFlatBuffersYYMsgAckStartMatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgAckStartMatch>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgAckStartMatch) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgAckStartMatch");
static_assert(sizeof(UFlatBuffersYYMsgAckStartMatch) == 0x000028, "Wrong size on UFlatBuffersYYMsgAckStartMatch");

// Class SiliconRising.FlatBuffersYYMsgReqCancelMatch
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgReqCancelMatch final : public UObject
{
public:
	static bool PackReqCancelMatch(class UObject* InWorldContextObject, const struct FYYMsgReqCancelMatch& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackReqCancelMatch(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgReqCancelMatch* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgReqCancelMatch">();
	}
	static class UFlatBuffersYYMsgReqCancelMatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgReqCancelMatch>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgReqCancelMatch) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgReqCancelMatch");
static_assert(sizeof(UFlatBuffersYYMsgReqCancelMatch) == 0x000028, "Wrong size on UFlatBuffersYYMsgReqCancelMatch");

// Class SiliconRising.FlatBuffersYYMsgAckCancelMatch
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgAckCancelMatch final : public UObject
{
public:
	static bool PackAckCancelMatch(class UObject* InWorldContextObject, const struct FYYMsgAckCancelMatch& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackAckCancelMatch(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgAckCancelMatch* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgAckCancelMatch">();
	}
	static class UFlatBuffersYYMsgAckCancelMatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgAckCancelMatch>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgAckCancelMatch) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgAckCancelMatch");
static_assert(sizeof(UFlatBuffersYYMsgAckCancelMatch) == 0x000028, "Wrong size on UFlatBuffersYYMsgAckCancelMatch");

// Class SiliconRising.FlatBuffersYYMsgReqFinishMatch
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgReqFinishMatch final : public UObject
{
public:
	static bool PackReqFinishMatch(class UObject* InWorldContextObject, const struct FYYMsgReqFinishMatch& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackReqFinishMatch(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgReqFinishMatch* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgReqFinishMatch">();
	}
	static class UFlatBuffersYYMsgReqFinishMatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgReqFinishMatch>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgReqFinishMatch) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgReqFinishMatch");
static_assert(sizeof(UFlatBuffersYYMsgReqFinishMatch) == 0x000028, "Wrong size on UFlatBuffersYYMsgReqFinishMatch");

// Class SiliconRising.FlatBuffersYYMsgAckFinishMatch
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgAckFinishMatch final : public UObject
{
public:
	static bool PackAckFinishMatch(class UObject* InWorldContextObject, const struct FYYMsgAckFinishMatch& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackAckFinishMatch(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgAckFinishMatch* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgAckFinishMatch">();
	}
	static class UFlatBuffersYYMsgAckFinishMatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgAckFinishMatch>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgAckFinishMatch) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgAckFinishMatch");
static_assert(sizeof(UFlatBuffersYYMsgAckFinishMatch) == 0x000028, "Wrong size on UFlatBuffersYYMsgAckFinishMatch");

// Class SiliconRising.FlatBuffersYYMsgReqAckRoomMember
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgReqAckRoomMember final : public UObject
{
public:
	static bool PackReqAckRoomMember(class UObject* InWorldContextObject, const struct FYYMsgReqAckRoomMember& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackReqAckRoomMember(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgReqAckRoomMember* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgReqAckRoomMember">();
	}
	static class UFlatBuffersYYMsgReqAckRoomMember* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgReqAckRoomMember>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgReqAckRoomMember) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgReqAckRoomMember");
static_assert(sizeof(UFlatBuffersYYMsgReqAckRoomMember) == 0x000028, "Wrong size on UFlatBuffersYYMsgReqAckRoomMember");

// Class SiliconRising.FlatBuffersYYMsgReqAckEnterRoom
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgReqAckEnterRoom final : public UObject
{
public:
	static bool PackReqAckEnterRoom(class UObject* InWorldContextObject, const struct FYYMsgReqAckEnterRoom& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackReqAckEnterRoom(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgReqAckEnterRoom* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgReqAckEnterRoom">();
	}
	static class UFlatBuffersYYMsgReqAckEnterRoom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgReqAckEnterRoom>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgReqAckEnterRoom) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgReqAckEnterRoom");
static_assert(sizeof(UFlatBuffersYYMsgReqAckEnterRoom) == 0x000028, "Wrong size on UFlatBuffersYYMsgReqAckEnterRoom");

// Class SiliconRising.FlatBuffersYYMsgReqAckRoomInfo
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgReqAckRoomInfo final : public UObject
{
public:
	static bool PackReqAckRoomInfo(class UObject* InWorldContextObject, const struct FYYMsgReqAckRoomInfo& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackReqAckRoomInfo(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgReqAckRoomInfo* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgReqAckRoomInfo">();
	}
	static class UFlatBuffersYYMsgReqAckRoomInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgReqAckRoomInfo>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgReqAckRoomInfo) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgReqAckRoomInfo");
static_assert(sizeof(UFlatBuffersYYMsgReqAckRoomInfo) == 0x000028, "Wrong size on UFlatBuffersYYMsgReqAckRoomInfo");

// Class SiliconRising.FlatBuffersYYMsgReqAckRoomList
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgReqAckRoomList final : public UObject
{
public:
	static bool PackReqAckRoomList(class UObject* InWorldContextObject, const struct FYYMsgReqAckRoomList& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackReqAckRoomList(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgReqAckRoomList* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgReqAckRoomList">();
	}
	static class UFlatBuffersYYMsgReqAckRoomList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgReqAckRoomList>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgReqAckRoomList) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgReqAckRoomList");
static_assert(sizeof(UFlatBuffersYYMsgReqAckRoomList) == 0x000028, "Wrong size on UFlatBuffersYYMsgReqAckRoomList");

// Class SiliconRising.FlatBuffersYYMsgReqAckCreateRoom
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgReqAckCreateRoom final : public UObject
{
public:
	static bool PackReqAckCreateRoom(class UObject* InWorldContextObject, const struct FYYMsgReqAckCreateRoom& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackReqAckCreateRoom(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgReqAckCreateRoom* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgReqAckCreateRoom">();
	}
	static class UFlatBuffersYYMsgReqAckCreateRoom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgReqAckCreateRoom>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgReqAckCreateRoom) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgReqAckCreateRoom");
static_assert(sizeof(UFlatBuffersYYMsgReqAckCreateRoom) == 0x000028, "Wrong size on UFlatBuffersYYMsgReqAckCreateRoom");

// Class SiliconRising.FlatBuffersYYMsgReqAckQuickEnter
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgReqAckQuickEnter final : public UObject
{
public:
	static bool PackReqAckQuickEnter(class UObject* InWorldContextObject, const struct FYYMsgReqAckQuickEnter& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackReqAckQuickEnter(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgReqAckQuickEnter* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgReqAckQuickEnter">();
	}
	static class UFlatBuffersYYMsgReqAckQuickEnter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgReqAckQuickEnter>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgReqAckQuickEnter) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgReqAckQuickEnter");
static_assert(sizeof(UFlatBuffersYYMsgReqAckQuickEnter) == 0x000028, "Wrong size on UFlatBuffersYYMsgReqAckQuickEnter");

// Class SiliconRising.FlatBuffersYYMsgReqAckRoomStart
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgReqAckRoomStart final : public UObject
{
public:
	static bool PackReqAckRoomStart(class UObject* InWorldContextObject, const struct FYYMsgReqAckRoomStart& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackReqAckRoomStart(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgReqAckRoomStart* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgReqAckRoomStart">();
	}
	static class UFlatBuffersYYMsgReqAckRoomStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgReqAckRoomStart>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgReqAckRoomStart) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgReqAckRoomStart");
static_assert(sizeof(UFlatBuffersYYMsgReqAckRoomStart) == 0x000028, "Wrong size on UFlatBuffersYYMsgReqAckRoomStart");

// Class SiliconRising.FlatBuffersYYMsgReqAckHeadUrl
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgReqAckHeadUrl final : public UObject
{
public:
	static bool PackReqAckHeadUrl(class UObject* InWorldContextObject, const struct FYYMsgReqAckHeadUrl& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackReqAckHeadUrl(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgReqAckHeadUrl* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgReqAckHeadUrl">();
	}
	static class UFlatBuffersYYMsgReqAckHeadUrl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgReqAckHeadUrl>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgReqAckHeadUrl) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgReqAckHeadUrl");
static_assert(sizeof(UFlatBuffersYYMsgReqAckHeadUrl) == 0x000028, "Wrong size on UFlatBuffersYYMsgReqAckHeadUrl");

// Class SiliconRising.FlatBuffersYYMsgReqAckLoaderServerRegister
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgReqAckLoaderServerRegister final : public UObject
{
public:
	static bool PackReqAckLoaderServerRegister(class UObject* InWorldContextObject, const struct FYYMsgReqAckLoaderServerRegister& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackReqAckLoaderServerRegister(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgReqAckLoaderServerRegister* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgReqAckLoaderServerRegister">();
	}
	static class UFlatBuffersYYMsgReqAckLoaderServerRegister* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgReqAckLoaderServerRegister>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgReqAckLoaderServerRegister) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgReqAckLoaderServerRegister");
static_assert(sizeof(UFlatBuffersYYMsgReqAckLoaderServerRegister) == 0x000028, "Wrong size on UFlatBuffersYYMsgReqAckLoaderServerRegister");

// Class SiliconRising.FlatBuffersYYMsgReqAckLoadPVPServer
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgReqAckLoadPVPServer final : public UObject
{
public:
	static bool PackReqAckLoadPVPServer(class UObject* InWorldContextObject, const struct FYYMsgReqAckLoadPVPServer& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackReqAckLoadPVPServer(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgReqAckLoadPVPServer* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgReqAckLoadPVPServer">();
	}
	static class UFlatBuffersYYMsgReqAckLoadPVPServer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgReqAckLoadPVPServer>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgReqAckLoadPVPServer) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgReqAckLoadPVPServer");
static_assert(sizeof(UFlatBuffersYYMsgReqAckLoadPVPServer) == 0x000028, "Wrong size on UFlatBuffersYYMsgReqAckLoadPVPServer");

// Class SiliconRising.FlatBuffersYYMsgPVPPlayerInfo
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgPVPPlayerInfo final : public UObject
{
public:
	static bool PackPVPPlayerInfo(class UObject* InWorldContextObject, const struct FYYMsgPVPPlayerInfo& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackPVPPlayerInfo(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgPVPPlayerInfo* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgPVPPlayerInfo">();
	}
	static class UFlatBuffersYYMsgPVPPlayerInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgPVPPlayerInfo>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgPVPPlayerInfo) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgPVPPlayerInfo");
static_assert(sizeof(UFlatBuffersYYMsgPVPPlayerInfo) == 0x000028, "Wrong size on UFlatBuffersYYMsgPVPPlayerInfo");

// Class SiliconRising.FlatBuffersYYMsgReqAckPVPServerRegister
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgReqAckPVPServerRegister final : public UObject
{
public:
	static bool PackReqAckPVPServerRegister(class UObject* InWorldContextObject, const struct FYYMsgReqAckPVPServerRegister& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackReqAckPVPServerRegister(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgReqAckPVPServerRegister* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgReqAckPVPServerRegister">();
	}
	static class UFlatBuffersYYMsgReqAckPVPServerRegister* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgReqAckPVPServerRegister>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgReqAckPVPServerRegister) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgReqAckPVPServerRegister");
static_assert(sizeof(UFlatBuffersYYMsgReqAckPVPServerRegister) == 0x000028, "Wrong size on UFlatBuffersYYMsgReqAckPVPServerRegister");

// Class SiliconRising.FlatBuffersYYMsgReqAckPVPServerStart
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgReqAckPVPServerStart final : public UObject
{
public:
	static bool PackReqAckPVPServerStart(class UObject* InWorldContextObject, const struct FYYMsgReqAckPVPServerStart& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackReqAckPVPServerStart(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgReqAckPVPServerStart* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgReqAckPVPServerStart">();
	}
	static class UFlatBuffersYYMsgReqAckPVPServerStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgReqAckPVPServerStart>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgReqAckPVPServerStart) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgReqAckPVPServerStart");
static_assert(sizeof(UFlatBuffersYYMsgReqAckPVPServerStart) == 0x000028, "Wrong size on UFlatBuffersYYMsgReqAckPVPServerStart");

// Class SiliconRising.FlatBuffersYYMsgReqAckPVPServerInfo
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgReqAckPVPServerInfo final : public UObject
{
public:
	static bool PackReqAckPVPServerInfo(class UObject* InWorldContextObject, const struct FYYMsgReqAckPVPServerInfo& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackReqAckPVPServerInfo(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgReqAckPVPServerInfo* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgReqAckPVPServerInfo">();
	}
	static class UFlatBuffersYYMsgReqAckPVPServerInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgReqAckPVPServerInfo>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgReqAckPVPServerInfo) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgReqAckPVPServerInfo");
static_assert(sizeof(UFlatBuffersYYMsgReqAckPVPServerInfo) == 0x000028, "Wrong size on UFlatBuffersYYMsgReqAckPVPServerInfo");

// Class SiliconRising.FlatBuffersYYMsgReqAckPVPServerFinished
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgReqAckPVPServerFinished final : public UObject
{
public:
	static bool PackReqAckPVPServerFinished(class UObject* InWorldContextObject, const struct FYYMsgReqAckPVPServerFinished& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackReqAckPVPServerFinished(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgReqAckPVPServerFinished* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgReqAckPVPServerFinished">();
	}
	static class UFlatBuffersYYMsgReqAckPVPServerFinished* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgReqAckPVPServerFinished>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgReqAckPVPServerFinished) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgReqAckPVPServerFinished");
static_assert(sizeof(UFlatBuffersYYMsgReqAckPVPServerFinished) == 0x000028, "Wrong size on UFlatBuffersYYMsgReqAckPVPServerFinished");

// Class SiliconRising.FlatBuffersYYMsgReqAckPVPShutDown
// 0x0000 (0x0028 - 0x0028)
class UFlatBuffersYYMsgReqAckPVPShutDown final : public UObject
{
public:
	static bool PackReqAckPVPShutDown(class UObject* InWorldContextObject, const struct FYYMsgReqAckPVPShutDown& InUE4Data, TArray<uint8>* OutData);
	static bool UnpackReqAckPVPShutDown(class UObject* InWorldContextObject, const TArray<uint8>& InData, struct FYYMsgReqAckPVPShutDown* OutUE4Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlatBuffersYYMsgReqAckPVPShutDown">();
	}
	static class UFlatBuffersYYMsgReqAckPVPShutDown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlatBuffersYYMsgReqAckPVPShutDown>();
	}
};
static_assert(alignof(UFlatBuffersYYMsgReqAckPVPShutDown) == 0x000008, "Wrong alignment on UFlatBuffersYYMsgReqAckPVPShutDown");
static_assert(sizeof(UFlatBuffersYYMsgReqAckPVPShutDown) == 0x000028, "Wrong size on UFlatBuffersYYMsgReqAckPVPShutDown");

// Class SiliconRising.YYMsgUtilDummy
// 0x0000 (0x0028 - 0x0028)
class UYYMsgUtilDummy final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"YYMsgUtilDummy">();
	}
	static class UYYMsgUtilDummy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UYYMsgUtilDummy>();
	}
};
static_assert(alignof(UYYMsgUtilDummy) == 0x000008, "Wrong alignment on UYYMsgUtilDummy");
static_assert(sizeof(UYYMsgUtilDummy) == 0x000028, "Wrong size on UYYMsgUtilDummy");

}

