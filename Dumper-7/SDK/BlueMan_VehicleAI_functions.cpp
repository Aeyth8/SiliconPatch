#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BlueMan_VehicleAI

#include "Basic.hpp"

#include "BlueMan_VehicleAI_classes.hpp"
#include "BlueMan_VehicleAI_parameters.hpp"


namespace SDK
{

// Function BlueMan_VehicleAI.AdvancedPathfindingController.SearchForNewVehicles
// (Final, Native, Public, BlueprintCallable)

void AAdvancedPathfindingController::SearchForNewVehicles()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AdvancedPathfindingController", "SearchForNewVehicles");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function BlueMan_VehicleAI.VehicleAI_AdvancedPathfinding.DisableVehicleAIModule
// (Final, Native, Public, BlueprintCallable)

void UVehicleAI_AdvancedPathfinding::DisableVehicleAIModule()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleAI_AdvancedPathfinding", "DisableVehicleAIModule");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function BlueMan_VehicleAI.VehicleAI_AdvancedPathfinding.EnableVehicleAIModule
// (Final, Native, Public, BlueprintCallable)

void UVehicleAI_AdvancedPathfinding::EnableVehicleAIModule()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleAI_AdvancedPathfinding", "EnableVehicleAIModule");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function BlueMan_VehicleAI.VehicleAI_AdvancedPathfinding.FindPath
// (Final, Native, Public, BlueprintCallable)

void UVehicleAI_AdvancedPathfinding::FindPath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleAI_AdvancedPathfinding", "FindPath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function BlueMan_VehicleAI.VehicleAI_AdvancedPathfinding.GetAllRuntimeData
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  SteeringOutput                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  ThrottleOutput                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>*                  PathData                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// float*                                  SteeringAngleData                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>*                  ParentData                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FVector>*                 DataStorageData                                        (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<float>*                          ValueData                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class AActor*>*                  OpenListData                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class AActor*>*                  ClosedListData                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class AActor*>*                  NeighboursData                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// float*                                  RightSensorAlphaData                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  CentralSensorAlphaData                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  LeftSensorAlphaData                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   IsVehicleAIModuleEnabledData                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVehicleAI_AdvancedPathfinding::GetAllRuntimeData(float* SteeringOutput, float* ThrottleOutput, TArray<class AActor*>* PathData, float* SteeringAngleData, TArray<class AActor*>* ParentData, TArray<struct FVector>* DataStorageData, TArray<float>* ValueData, TArray<class AActor*>* OpenListData, TArray<class AActor*>* ClosedListData, TArray<class AActor*>* NeighboursData, float* RightSensorAlphaData, float* CentralSensorAlphaData, float* LeftSensorAlphaData, bool* IsVehicleAIModuleEnabledData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleAI_AdvancedPathfinding", "GetAllRuntimeData");

	Params::VehicleAI_AdvancedPathfinding_GetAllRuntimeData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SteeringOutput != nullptr)
		*SteeringOutput = Parms.SteeringOutput;

	if (ThrottleOutput != nullptr)
		*ThrottleOutput = Parms.ThrottleOutput;

	if (PathData != nullptr)
		*PathData = std::move(Parms.PathData);

	if (SteeringAngleData != nullptr)
		*SteeringAngleData = Parms.SteeringAngleData;

	if (ParentData != nullptr)
		*ParentData = std::move(Parms.ParentData);

	if (DataStorageData != nullptr)
		*DataStorageData = std::move(Parms.DataStorageData);

	if (ValueData != nullptr)
		*ValueData = std::move(Parms.ValueData);

	if (OpenListData != nullptr)
		*OpenListData = std::move(Parms.OpenListData);

	if (ClosedListData != nullptr)
		*ClosedListData = std::move(Parms.ClosedListData);

	if (NeighboursData != nullptr)
		*NeighboursData = std::move(Parms.NeighboursData);

	if (RightSensorAlphaData != nullptr)
		*RightSensorAlphaData = Parms.RightSensorAlphaData;

	if (CentralSensorAlphaData != nullptr)
		*CentralSensorAlphaData = Parms.CentralSensorAlphaData;

	if (LeftSensorAlphaData != nullptr)
		*LeftSensorAlphaData = Parms.LeftSensorAlphaData;

	if (IsVehicleAIModuleEnabledData != nullptr)
		*IsVehicleAIModuleEnabledData = Parms.IsVehicleAIModuleEnabledData;
}


// Function BlueMan_VehicleAI.VehicleAI_AdvancedPathfinding.RecalculateStaticWaypointConnections
// (Final, Native, Public, BlueprintCallable)

void UVehicleAI_AdvancedPathfinding::RecalculateStaticWaypointConnections()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleAI_AdvancedPathfinding", "RecalculateStaticWaypointConnections");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function BlueMan_VehicleAI.VehicleAI_AdvancedPathfinding.SetPathfindingDestination
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Destination                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVehicleAI_AdvancedPathfinding::SetPathfindingDestination(class AActor* Destination)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleAI_AdvancedPathfinding", "SetPathfindingDestination");

	Params::VehicleAI_AdvancedPathfinding_SetPathfindingDestination Parms{};

	Parms.Destination = Destination;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function BlueMan_VehicleAI.VehicleAI_AdvancedPathfinding.SetRequiredProperties
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AWheeledVehicle*                  WheeledVehicleReferenceInput                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UArrowComponent*                  LeftSensorInput                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UArrowComponent*                  CentralSensorInput                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UArrowComponent*                  RightSensorInput                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ActorInput                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            WaypointsInput                                         (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UVehicleAI_AdvancedPathfinding::SetRequiredProperties(class AWheeledVehicle* WheeledVehicleReferenceInput, class UArrowComponent* LeftSensorInput, class UArrowComponent* CentralSensorInput, class UArrowComponent* RightSensorInput, class AActor* ActorInput, const TArray<class AActor*>& WaypointsInput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleAI_AdvancedPathfinding", "SetRequiredProperties");

	Params::VehicleAI_AdvancedPathfinding_SetRequiredProperties Parms{};

	Parms.WheeledVehicleReferenceInput = WheeledVehicleReferenceInput;
	Parms.LeftSensorInput = LeftSensorInput;
	Parms.CentralSensorInput = CentralSensorInput;
	Parms.RightSensorInput = RightSensorInput;
	Parms.ActorInput = ActorInput;
	Parms.WaypointsInput = std::move(WaypointsInput);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function BlueMan_VehicleAI.VehicleAIModule_DeathMatch.ActivateAI
// (Final, Native, Public, BlueprintCallable)

void UVehicleAIModule_DeathMatch::ActivateAI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleAIModule_DeathMatch", "ActivateAI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function BlueMan_VehicleAI.VehicleAIModule_DeathMatch.DisableVehicleAIModule
// (Final, Native, Public, BlueprintCallable)

void UVehicleAIModule_DeathMatch::DisableVehicleAIModule()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleAIModule_DeathMatch", "DisableVehicleAIModule");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function BlueMan_VehicleAI.VehicleAIModule_DeathMatch.EnableVehicleAIModule
// (Final, Native, Public, BlueprintCallable)

void UVehicleAIModule_DeathMatch::EnableVehicleAIModule()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleAIModule_DeathMatch", "EnableVehicleAIModule");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function BlueMan_VehicleAI.VehicleAIModule_DeathMatch.GetAllRuntimeData
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  ThrottleOutputData                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  SteeringOutputData                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         WaypointLocationData                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   InReverseData                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  SteeringAngleData                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   IsVehicleAIModuleEnabledData                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVehicleAIModule_DeathMatch::GetAllRuntimeData(float* ThrottleOutputData, float* SteeringOutputData, struct FVector* WaypointLocationData, bool* InReverseData, float* SteeringAngleData, bool* IsVehicleAIModuleEnabledData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleAIModule_DeathMatch", "GetAllRuntimeData");

	Params::VehicleAIModule_DeathMatch_GetAllRuntimeData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ThrottleOutputData != nullptr)
		*ThrottleOutputData = Parms.ThrottleOutputData;

	if (SteeringOutputData != nullptr)
		*SteeringOutputData = Parms.SteeringOutputData;

	if (WaypointLocationData != nullptr)
		*WaypointLocationData = std::move(Parms.WaypointLocationData);

	if (InReverseData != nullptr)
		*InReverseData = Parms.InReverseData;

	if (SteeringAngleData != nullptr)
		*SteeringAngleData = Parms.SteeringAngleData;

	if (IsVehicleAIModuleEnabledData != nullptr)
		*IsVehicleAIModuleEnabledData = Parms.IsVehicleAIModuleEnabledData;
}


// Function BlueMan_VehicleAI.VehicleAIModule_DeathMatch.ManuallySelectWaypoint
// (Final, Native, Public, BlueprintCallable)

void UVehicleAIModule_DeathMatch::ManuallySelectWaypoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleAIModule_DeathMatch", "ManuallySelectWaypoint");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function BlueMan_VehicleAI.VehicleAIModule_DeathMatch.SetRequiredProperties
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ActorInput                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AWheeledVehicle*                  VehicleMovementComponentInput                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            ArrayOfActorsUsedAsWaypointsInput                      (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class UArrowComponent*                  ArrowComponentInput                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UseHealthSystem                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            ArrayOfActorsUsedAsHealthPickupsInput                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UVehicleAIModule_DeathMatch::SetRequiredProperties(class AActor* ActorInput, class AWheeledVehicle* VehicleMovementComponentInput, const TArray<class AActor*>& ArrayOfActorsUsedAsWaypointsInput, class UArrowComponent* ArrowComponentInput, bool UseHealthSystem, const TArray<class AActor*>& ArrayOfActorsUsedAsHealthPickupsInput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleAIModule_DeathMatch", "SetRequiredProperties");

	Params::VehicleAIModule_DeathMatch_SetRequiredProperties Parms{};

	Parms.ActorInput = ActorInput;
	Parms.VehicleMovementComponentInput = VehicleMovementComponentInput;
	Parms.ArrayOfActorsUsedAsWaypointsInput = std::move(ArrayOfActorsUsedAsWaypointsInput);
	Parms.ArrowComponentInput = ArrowComponentInput;
	Parms.UseHealthSystem = UseHealthSystem;
	Parms.ArrayOfActorsUsedAsHealthPickupsInput = std::move(ArrayOfActorsUsedAsHealthPickupsInput);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function BlueMan_VehicleAI.VehicleAIModule_Racing.DisableVehicleAIModule
// (Final, Native, Public, BlueprintCallable)

void UVehicleAIModule_Racing::DisableVehicleAIModule()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleAIModule_Racing", "DisableVehicleAIModule");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function BlueMan_VehicleAI.VehicleAIModule_Racing.EnableVehicleAIModule
// (Final, Native, Public, BlueprintCallable)

void UVehicleAIModule_Racing::EnableVehicleAIModule()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleAIModule_Racing", "EnableVehicleAIModule");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function BlueMan_VehicleAI.VehicleAIModule_Racing.GetAllRuntimeData
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float*                                  ThrottleOutputData                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  SteeringOutputData                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   IsVehicleAIModuleEnabledData                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   GoInReverseData                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  SteeringAngleData                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  AvoidanceSteeringLevelData                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARacingAI_Waypoint**              CurrentWaypointData                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor**                          WaypointData                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  LeftSensorAlphaData                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  RightSensorAlphaData                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  CentralSensorAlphaData                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   IsCurrentWaypointDataValid                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   IsWaypointDataValid                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVehicleAIModule_Racing::GetAllRuntimeData(float* ThrottleOutputData, float* SteeringOutputData, bool* IsVehicleAIModuleEnabledData, bool* GoInReverseData, float* SteeringAngleData, float* AvoidanceSteeringLevelData, class ARacingAI_Waypoint** CurrentWaypointData, class AActor** WaypointData, float* LeftSensorAlphaData, float* RightSensorAlphaData, float* CentralSensorAlphaData, bool* IsCurrentWaypointDataValid, bool* IsWaypointDataValid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleAIModule_Racing", "GetAllRuntimeData");

	Params::VehicleAIModule_Racing_GetAllRuntimeData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ThrottleOutputData != nullptr)
		*ThrottleOutputData = Parms.ThrottleOutputData;

	if (SteeringOutputData != nullptr)
		*SteeringOutputData = Parms.SteeringOutputData;

	if (IsVehicleAIModuleEnabledData != nullptr)
		*IsVehicleAIModuleEnabledData = Parms.IsVehicleAIModuleEnabledData;

	if (GoInReverseData != nullptr)
		*GoInReverseData = Parms.GoInReverseData;

	if (SteeringAngleData != nullptr)
		*SteeringAngleData = Parms.SteeringAngleData;

	if (AvoidanceSteeringLevelData != nullptr)
		*AvoidanceSteeringLevelData = Parms.AvoidanceSteeringLevelData;

	if (CurrentWaypointData != nullptr)
		*CurrentWaypointData = Parms.CurrentWaypointData;

	if (WaypointData != nullptr)
		*WaypointData = Parms.WaypointData;

	if (LeftSensorAlphaData != nullptr)
		*LeftSensorAlphaData = Parms.LeftSensorAlphaData;

	if (RightSensorAlphaData != nullptr)
		*RightSensorAlphaData = Parms.RightSensorAlphaData;

	if (CentralSensorAlphaData != nullptr)
		*CentralSensorAlphaData = Parms.CentralSensorAlphaData;

	if (IsCurrentWaypointDataValid != nullptr)
		*IsCurrentWaypointDataValid = Parms.IsCurrentWaypointDataValid;

	if (IsWaypointDataValid != nullptr)
		*IsWaypointDataValid = Parms.IsWaypointDataValid;
}


// Function BlueMan_VehicleAI.VehicleAIModule_Racing.SetNextWaypoint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ARacingAI_Waypoint*               NextWaypointActor                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVehicleAIModule_Racing::SetNextWaypoint(class ARacingAI_Waypoint* NextWaypointActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleAIModule_Racing", "SetNextWaypoint");

	Params::VehicleAIModule_Racing_SetNextWaypoint Parms{};

	Parms.NextWaypointActor = NextWaypointActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function BlueMan_VehicleAI.VehicleAIModule_Racing.SetRequiredProperties
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UArrowComponent*                  RightSensorArrowInput                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UArrowComponent*                  CentralSensorArrowInput                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UArrowComponent*                  LeftSensorArrowInput                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AWheeledVehicle*                  WheeledVehicleReferenceInput                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ActorInput                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVehicleAIModule_Racing::SetRequiredProperties(class UArrowComponent* RightSensorArrowInput, class UArrowComponent* CentralSensorArrowInput, class UArrowComponent* LeftSensorArrowInput, class AWheeledVehicle* WheeledVehicleReferenceInput, class AActor* ActorInput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleAIModule_Racing", "SetRequiredProperties");

	Params::VehicleAIModule_Racing_SetRequiredProperties Parms{};

	Parms.RightSensorArrowInput = RightSensorArrowInput;
	Parms.CentralSensorArrowInput = CentralSensorArrowInput;
	Parms.LeftSensorArrowInput = LeftSensorArrowInput;
	Parms.WheeledVehicleReferenceInput = WheeledVehicleReferenceInput;
	Parms.ActorInput = ActorInput;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

