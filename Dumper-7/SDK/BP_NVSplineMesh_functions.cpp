#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_NVSplineMesh

#include "Basic.hpp"

#include "BP_NVSplineMesh_classes.hpp"
#include "BP_NVSplineMesh_parameters.hpp"


namespace SDK
{

// Function BP_NVSplineMesh.BP_NVSplineMesh_C.UserConstructionScript
// (Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_NVSplineMesh_C::UserConstructionScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NVSplineMesh_C", "UserConstructionScript");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NVSplineMesh.BP_NVSplineMesh_C.BuildMeshSequence
// (Private, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSSplineMeshDetails&       SplineMeshDetails_0                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, HasGetValueTypeHash)
// float                                   StartDistance                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   EndDistnace                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FSSplineMeshStep>*        Mesh_segment_sequence                                  (Parm, OutParm, ZeroConstructor)

void ABP_NVSplineMesh_C::BuildMeshSequence(const struct FSSplineMeshDetails& SplineMeshDetails_0, float StartDistance, float EndDistnace, TArray<struct FSSplineMeshStep>* Mesh_segment_sequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NVSplineMesh_C", "BuildMeshSequence");

	Params::BP_NVSplineMesh_C_BuildMeshSequence Parms{};

	Parms.SplineMeshDetails_0 = std::move(SplineMeshDetails_0);
	Parms.StartDistance = StartDistance;
	Parms.EndDistnace = EndDistnace;

	UObject::ProcessEvent(Func, &Parms);

	if (Mesh_segment_sequence != nullptr)
		*Mesh_segment_sequence = std::move(Parms.Mesh_segment_sequence);
}


// Function BP_NVSplineMesh.BP_NVSplineMesh_C.GetLongestMeshes
// (Private, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<class UStaticMesh*>&             Meshes                                                 (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm)
// float                                   Tolerance                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class UStaticMesh*>*             Matching_Meshes                                        (Parm, OutParm, ZeroConstructor)

void ABP_NVSplineMesh_C::GetLongestMeshes(TArray<class UStaticMesh*>& Meshes, float Tolerance, TArray<class UStaticMesh*>* Matching_Meshes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NVSplineMesh_C", "GetLongestMeshes");

	Params::BP_NVSplineMesh_C_GetLongestMeshes Parms{};

	Parms.Meshes = std::move(Meshes);
	Parms.Tolerance = Tolerance;

	UObject::ProcessEvent(Func, &Parms);

	Meshes = std::move(Parms.Meshes);

	if (Matching_Meshes != nullptr)
		*Matching_Meshes = std::move(Parms.Matching_Meshes);
}


// Function BP_NVSplineMesh.BP_NVSplineMesh_C.ChooseNextMeshInSequence
// (Private, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSSplineMeshDetails&       SplineMeshDetails_0                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, HasGetValueTypeHash)
// bool                                    First                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UStaticMesh**                     Chosen_Mesh                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NVSplineMesh_C::ChooseNextMeshInSequence(const struct FSSplineMeshDetails& SplineMeshDetails_0, bool First, class UStaticMesh** Chosen_Mesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NVSplineMesh_C", "ChooseNextMeshInSequence");

	Params::BP_NVSplineMesh_C_ChooseNextMeshInSequence Parms{};

	Parms.SplineMeshDetails_0 = std::move(SplineMeshDetails_0);
	Parms.First = First;

	UObject::ProcessEvent(Func, &Parms);

	if (Chosen_Mesh != nullptr)
		*Chosen_Mesh = Parms.Chosen_Mesh;
}


// Function BP_NVSplineMesh.BP_NVSplineMesh_C.FindBestMeshForLength
// (Private, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FSSplineMeshDetails&       Mesh_Details                                           (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, HasGetValueTypeHash)
// float                                   Desired_Length                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UStaticMesh*                      InitialChoice                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UStaticMesh**                     ChosenMesh                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NVSplineMesh_C::FindBestMeshForLength(const struct FSSplineMeshDetails& Mesh_Details, float Desired_Length, class UStaticMesh* InitialChoice, class UStaticMesh** ChosenMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NVSplineMesh_C", "FindBestMeshForLength");

	Params::BP_NVSplineMesh_C_FindBestMeshForLength Parms{};

	Parms.Mesh_Details = std::move(Mesh_Details);
	Parms.Desired_Length = Desired_Length;
	Parms.InitialChoice = InitialChoice;

	UObject::ProcessEvent(Func, &Parms);

	if (ChosenMesh != nullptr)
		*ChosenMesh = Parms.ChosenMesh;
}


// Function BP_NVSplineMesh.BP_NVSplineMesh_C.PlaceMeshSequence
// (Private, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FSSplineMeshStep>&        Mesh_Sequence                                          (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm)
// const struct FSSplineMeshDetails&       SplineMeshDetails_0                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, HasGetValueTypeHash)
// TArray<struct FSSplineMeshDetails>&     Dependants                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm)
// int32                                   MeshSequenceNumber                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NVSplineMesh_C::PlaceMeshSequence(TArray<struct FSSplineMeshStep>& Mesh_Sequence, const struct FSSplineMeshDetails& SplineMeshDetails_0, TArray<struct FSSplineMeshDetails>& Dependants, int32 MeshSequenceNumber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NVSplineMesh_C", "PlaceMeshSequence");

	Params::BP_NVSplineMesh_C_PlaceMeshSequence Parms{};

	Parms.Mesh_Sequence = std::move(Mesh_Sequence);
	Parms.SplineMeshDetails_0 = std::move(SplineMeshDetails_0);
	Parms.Dependants = std::move(Dependants);
	Parms.MeshSequenceNumber = MeshSequenceNumber;

	UObject::ProcessEvent(Func, &Parms);

	Mesh_Sequence = std::move(Parms.Mesh_Sequence);
	Dependants = std::move(Parms.Dependants);
}


// Function BP_NVSplineMesh.BP_NVSplineMesh_C.CreateStaticMeshesAtDistancesAlongSpline
// (Private, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSSplineMeshDetails&       Spline_Mesh_Details                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_NVSplineMesh_C::CreateStaticMeshesAtDistancesAlongSpline(const struct FSSplineMeshDetails& Spline_Mesh_Details)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NVSplineMesh_C", "CreateStaticMeshesAtDistancesAlongSpline");

	Params::BP_NVSplineMesh_C_CreateStaticMeshesAtDistancesAlongSpline Parms{};

	Parms.Spline_Mesh_Details = std::move(Spline_Mesh_Details);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_NVSplineMesh.BP_NVSplineMesh_C.PlaceDependants
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FSSplineMeshDetails>&     Dependants                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm)
// float                                   Distance_0                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsStart                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    IsMiddle                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    IsEnd                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_NVSplineMesh_C::PlaceDependants(TArray<struct FSSplineMeshDetails>& Dependants, float Distance_0, bool IsStart, bool IsMiddle, bool IsEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NVSplineMesh_C", "PlaceDependants");

	Params::BP_NVSplineMesh_C_PlaceDependants Parms{};

	Parms.Dependants = std::move(Dependants);
	Parms.Distance_0 = Distance_0;
	Parms.IsStart = IsStart;
	Parms.IsMiddle = IsMiddle;
	Parms.IsEnd = IsEnd;

	UObject::ProcessEvent(Func, &Parms);

	Dependants = std::move(Parms.Dependants);
}


// Function BP_NVSplineMesh.BP_NVSplineMesh_C.CreateStaticMeshAtDistanceAlongSplineFunc
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UStaticMesh*                      Mesh                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Distance_0                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FSSplineMeshDetails&       SplineMeshDetails_0                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_NVSplineMesh_C::CreateStaticMeshAtDistanceAlongSplineFunc(class UStaticMesh* Mesh, float Distance_0, const struct FSSplineMeshDetails& SplineMeshDetails_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NVSplineMesh_C", "CreateStaticMeshAtDistanceAlongSplineFunc");

	Params::BP_NVSplineMesh_C_CreateStaticMeshAtDistanceAlongSplineFunc Parms{};

	Parms.Mesh = Mesh;
	Parms.Distance_0 = Distance_0;
	Parms.SplineMeshDetails_0 = std::move(SplineMeshDetails_0);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_NVSplineMesh.BP_NVSplineMesh_C.CreateSplineMeshBetweenTwoDistancesAlongSpline
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UStaticMesh*                      Mesh                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Start_Distance                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   End_Distance                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Gap                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class USplineMeshComponent**            CreatedSplineMesh                                      (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NVSplineMesh_C::CreateSplineMeshBetweenTwoDistancesAlongSpline(class UStaticMesh* Mesh, float Start_Distance, float End_Distance, float Gap, class USplineMeshComponent** CreatedSplineMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NVSplineMesh_C", "CreateSplineMeshBetweenTwoDistancesAlongSpline");

	Params::BP_NVSplineMesh_C_CreateSplineMeshBetweenTwoDistancesAlongSpline Parms{};

	Parms.Mesh = Mesh;
	Parms.Start_Distance = Start_Distance;
	Parms.End_Distance = End_Distance;
	Parms.Gap = Gap;

	UObject::ProcessEvent(Func, &Parms);

	if (CreatedSplineMesh != nullptr)
		*CreatedSplineMesh = Parms.CreatedSplineMesh;
}


// Function BP_NVSplineMesh.BP_NVSplineMesh_C.BuildSplineMeshSequence
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_NVSplineMesh_C::BuildSplineMeshSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NVSplineMesh_C", "BuildSplineMeshSequence");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NVSplineMesh.BP_NVSplineMesh_C.DropSplinePointsToGround
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_NVSplineMesh_C::DropSplinePointsToGround()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NVSplineMesh_C", "DropSplinePointsToGround");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NVSplineMesh.BP_NVSplineMesh_C.SetSplinePointCurveTypes
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ESplinePointType                        Type                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NVSplineMesh_C::SetSplinePointCurveTypes(ESplinePointType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NVSplineMesh_C", "SetSplinePointCurveTypes");

	Params::BP_NVSplineMesh_C_SetSplinePointCurveTypes Parms{};

	Parms.Type = Type;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_NVSplineMesh.BP_NVSplineMesh_C.ClearStaticMeshInstances
// (Private, BlueprintCallable, BlueprintEvent)

void ABP_NVSplineMesh_C::ClearStaticMeshInstances()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NVSplineMesh_C", "ClearStaticMeshInstances");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_NVSplineMesh.BP_NVSplineMesh_C.PlaceSplineMeshBetweenTwoDistances
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USplineMeshComponent*             SplineMeshComponent                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UStaticMesh*                      NewMesh                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   StartDistance                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   EndDistance                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Gap                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_NVSplineMesh_C::PlaceSplineMeshBetweenTwoDistances(class USplineMeshComponent* SplineMeshComponent, class UStaticMesh* NewMesh, float StartDistance, float EndDistance, float Gap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NVSplineMesh_C", "PlaceSplineMeshBetweenTwoDistances");

	Params::BP_NVSplineMesh_C_PlaceSplineMeshBetweenTwoDistances Parms{};

	Parms.SplineMeshComponent = SplineMeshComponent;
	Parms.NewMesh = NewMesh;
	Parms.StartDistance = StartDistance;
	Parms.EndDistance = EndDistance;
	Parms.Gap = Gap;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_NVSplineMesh.BP_NVSplineMesh_C.CalculatePositionForStaticMeshAtDistance
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   Distance_0                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FSSplineMeshDetails&       SplineMeshDetails_0                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor)

struct FTransform ABP_NVSplineMesh_C::CalculatePositionForStaticMeshAtDistance(float Distance_0, const struct FSSplineMeshDetails& SplineMeshDetails_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_NVSplineMesh_C", "CalculatePositionForStaticMeshAtDistance");

	Params::BP_NVSplineMesh_C_CalculatePositionForStaticMeshAtDistance Parms{};

	Parms.Distance_0 = Distance_0;
	Parms.SplineMeshDetails_0 = std::move(SplineMeshDetails_0);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}

}

