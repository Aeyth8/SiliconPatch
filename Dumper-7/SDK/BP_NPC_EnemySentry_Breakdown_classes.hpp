#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_NPC_EnemySentry_Breakdown

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "BP_NPC_Base_classes.hpp"
#include "Enum_BehaviorType_structs.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass BP_NPC_EnemySentry_Breakdown.BP_NPC_EnemySentry_Breakdown_C
// 0x01A0 (0x0A50 - 0x08B0)
class ABP_NPC_EnemySentry_Breakdown_C final : public ABP_NPC_Base_C
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame_BP_NPC_EnemySentry_Breakdown_C;     // 0x08B0(0x0008)(ZeroConstructor, Transient, DuplicateTransient)
	class USkeletalMeshComponent*                 BrokenMesh;                                        // 0x08B8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	float                                         HitReactionTime;                                   // 0x08C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         HitReactionTimeCurrent;                            // 0x08C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   AttackSpeed;                                       // 0x08C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   AttackSpeedMax;                                    // 0x08D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   SwitchCoverTimeMin;                                // 0x08D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   SwitchCoverTimeMax;                                // 0x08E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsInitSettings;                                    // 0x08E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8E9[0x3];                                      // 0x08E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AttackSpeed_Min_;                                  // 0x08EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         AttackSpeed_Max_;                                  // 0x08F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         SwitchCoverInterval_Min_;                          // 0x08F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         SwitchCoverInterval_Max_;                          // 0x08F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsHeadShotDead;                                    // 0x08FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	Enum_BehaviorType                             HitTransition;                                     // 0x08FD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_8FE[0x2];                                      // 0x08FE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DodgeRate;                                         // 0x0900(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         DodgeCD_Min_;                                      // 0x0904(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         DodgeCD_Max_;                                      // 0x0908(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsAimMe;                                           // 0x090C(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsPlayDodge;                                       // 0x090D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_90E[0x2];                                      // 0x090E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAnimMontage*>                   RunHurtAM;                                         // 0x0910(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance)
	TArray<class UAnimMontage*>                   CrouchHurtAM;                                      // 0x0920(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance)
	TArray<class UAnimMontage*>                   StandHurtAM;                                       // 0x0930(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance)
	TArray<class UAnimMontage*>                   FireAM;                                            // 0x0940(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance)
	TArray<class UAnimMontage*>                   ReloadAM;                                          // 0x0950(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance)
	float                                         AimPitch;                                          // 0x0960(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         DTime;                                             // 0x0964(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UAnimBP_EnemySentry_RootMotion_C*       AnimBP;                                            // 0x0968(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         MiniBreakThreshold;                                // 0x0970(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         MaxBreakThreshold;                                 // 0x0974(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsMoving;                                          // 0x0978(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsHurting;                                         // 0x0979(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsReloading;                                       // 0x097A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_97B[0x1];                                      // 0x097B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         State;                                             // 0x097C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                MoveTargetLocation;                                // 0x0980(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          ShouldAttack;                                      // 0x098C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_98D[0x3];                                      // 0x098D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RandomCount;                                       // 0x0990(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         Timespan;                                          // 0x0994(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsCrouch;                                          // 0x0998(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_999[0x7];                                      // 0x0999(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        Waypoint;                                          // 0x09A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance)
	bool                                          IsShowWayPoint;                                    // 0x09B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_9B1[0x3];                                      // 0x09B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FreshWayPointTime;                                 // 0x09B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         CheckAvoid;                                        // 0x09B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                FixedTargetLocation;                               // 0x09BC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         ShootAvoid;                                        // 0x09C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                LastLocation;                                      // 0x09CC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         MovingStuckCheckTime;                              // 0x09D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         GoToStartPathCheckTime;                            // 0x09DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          DeathCheck;                                        // 0x09E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_9E1[0x3];                                      // 0x09E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TempTargetLocation;                                // 0x09E4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsFirstSwitch;                                     // 0x09F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsAllowRollOffset;                                 // 0x09F1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_9F2[0x2];                                      // 0x09F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FireInterval;                                      // 0x09F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsForceStop;                                       // 0x09F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_9F9[0x3];                                      // 0x09F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HitCount;                                          // 0x09FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          ForceStopCheck;                                    // 0x0A00(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_A01[0x3];                                      // 0x0A01(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BulletReloadCount;                                 // 0x0A04(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsStartAimRoll;                                    // 0x0A08(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_A09[0x3];                                      // 0x0A09(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                NewVar_0_0;                                        // 0x0A0C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsInFirstShow;                                     // 0x0A18(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_A19[0x7];                                      // 0x0A19(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAnimMontage*>                   ShowUp;                                            // 0x0A20(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance)
	TArray<class FName>                           TempList;                                          // 0x0A30(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance)
	int32                                         FindTarget;                                        // 0x0A40(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

public:
	void ExecuteUbergraph_BP_NPC_EnemySentry_Breakdown(int32 EntryPoint);
	void Init();
	void BndEvt__CapsuleComponent_K2Node_ComponentBoundEvent_0_ComponentHitSignature__DelegateSignature(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnCheckMovingStuck();
	void ReloadBullet();
	void OnHurt();
	void OnDodgeCheck();
	void BndEvt__BehaviorComponent_K2Node_ComponentBoundEvent_0_OnEndAttackRanged__DelegateSignature();
	void OnTickSwitchCover();
	void Stage_OnChangeCover(bool OnOrOff);
	void OnTickGoStartLocation();
	void Stage_StartPath(bool OnOrOff);
	void OnTickRandomMove();
	void OnRandomMove(bool OnOrOff, const struct FVector& Direction);
	void OnAnim_IsUseIK(bool Value);
	void OnAim_IsForceQuitMove(bool Value);
	void OnAnim_AimDirection(float Value);
	void OnAnim_AimPich(float Value);
	void OnAnim_CurrentSpeed(float Value);
	void OnAnim_CurrentDirection(float Value);
	void OnAnim_moveStartDirection(float Value);
	void OnHitOtherDead(const struct FVector& HitLocation_0, const struct FVector& HitNormal_0, class APlayerController* PlayerController);
	void OnAnim_SetIsCrouching(bool Value);
	void OnAnim_SetLockingTarget(bool Value);
	void OnAnim_SetMoving(bool Value);
	void FaceToTarget(const struct FVector& TargetLocation);
	void HitOtherDead(const struct FVector& HitLocation_0, int32* BreakType);
	void GetRandomBoneList(TArray<class FName>* BoneList);
	void GoToTargetLocation(const struct FVector& PathEnd, float MiniSpeed, float MaxSpeed);
	void GoToTargetLocationWithLockTarget(struct FVector& PathEnd, struct FVector& Target);
	void CheckAttackConditions(bool* CouldAttack);
	void FindRandomMoveLocation(const struct FVector& Direction, struct FVector* Location);
	void CheckCoverForCrouch(bool* Result);
	void UpperBodyFaceToTarget(const struct FVector& TargetLocation);
	void IsReachable(const struct FVector& TargetLocation, bool* IsReachable_0);
	void FindLocationRandom(struct FVector* Location);
	void UpperBodyAimOffset();
	void OnHitHeadDead(const struct FVector& HitLocation_0, const struct FVector& HitNormal_0, class APlayerController* PlayerController);
	void OnHitOther(class APlayerController* PlayerController, const struct FVector& HitLocation_0, const struct FVector& HitNormal_0);
	void OnHitBody(class APlayerController* PlayerController, const struct FVector& HitLocation_0, const struct FVector& HitNormal_0);
	void OnHitHead(class APlayerController* PlayerController, const struct FVector& HitLocation_0, const struct FVector& HitNormal_0);
	void OnDeath(class APlayerController* PlayerController);
	void ReceiveTick(float DeltaSeconds);
	void ReceiveAnyDamage(float Damage_0, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser);
	void ReceiveBeginPlay();
	void UserConstructionScript();

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"BP_NPC_EnemySentry_Breakdown_C">();
	}
	static class ABP_NPC_EnemySentry_Breakdown_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABP_NPC_EnemySentry_Breakdown_C>();
	}
};
static_assert(alignof(ABP_NPC_EnemySentry_Breakdown_C) == 0x000010, "Wrong alignment on ABP_NPC_EnemySentry_Breakdown_C");
static_assert(sizeof(ABP_NPC_EnemySentry_Breakdown_C) == 0x000A50, "Wrong size on ABP_NPC_EnemySentry_Breakdown_C");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, UberGraphFrame_BP_NPC_EnemySentry_Breakdown_C) == 0x0008B0, "Member 'ABP_NPC_EnemySentry_Breakdown_C::UberGraphFrame_BP_NPC_EnemySentry_Breakdown_C' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, BrokenMesh) == 0x0008B8, "Member 'ABP_NPC_EnemySentry_Breakdown_C::BrokenMesh' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, HitReactionTime) == 0x0008C0, "Member 'ABP_NPC_EnemySentry_Breakdown_C::HitReactionTime' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, HitReactionTimeCurrent) == 0x0008C4, "Member 'ABP_NPC_EnemySentry_Breakdown_C::HitReactionTimeCurrent' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, AttackSpeed) == 0x0008C8, "Member 'ABP_NPC_EnemySentry_Breakdown_C::AttackSpeed' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, AttackSpeedMax) == 0x0008D0, "Member 'ABP_NPC_EnemySentry_Breakdown_C::AttackSpeedMax' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, SwitchCoverTimeMin) == 0x0008D8, "Member 'ABP_NPC_EnemySentry_Breakdown_C::SwitchCoverTimeMin' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, SwitchCoverTimeMax) == 0x0008E0, "Member 'ABP_NPC_EnemySentry_Breakdown_C::SwitchCoverTimeMax' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, IsInitSettings) == 0x0008E8, "Member 'ABP_NPC_EnemySentry_Breakdown_C::IsInitSettings' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, AttackSpeed_Min_) == 0x0008EC, "Member 'ABP_NPC_EnemySentry_Breakdown_C::AttackSpeed_Min_' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, AttackSpeed_Max_) == 0x0008F0, "Member 'ABP_NPC_EnemySentry_Breakdown_C::AttackSpeed_Max_' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, SwitchCoverInterval_Min_) == 0x0008F4, "Member 'ABP_NPC_EnemySentry_Breakdown_C::SwitchCoverInterval_Min_' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, SwitchCoverInterval_Max_) == 0x0008F8, "Member 'ABP_NPC_EnemySentry_Breakdown_C::SwitchCoverInterval_Max_' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, IsHeadShotDead) == 0x0008FC, "Member 'ABP_NPC_EnemySentry_Breakdown_C::IsHeadShotDead' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, HitTransition) == 0x0008FD, "Member 'ABP_NPC_EnemySentry_Breakdown_C::HitTransition' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, DodgeRate) == 0x000900, "Member 'ABP_NPC_EnemySentry_Breakdown_C::DodgeRate' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, DodgeCD_Min_) == 0x000904, "Member 'ABP_NPC_EnemySentry_Breakdown_C::DodgeCD_Min_' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, DodgeCD_Max_) == 0x000908, "Member 'ABP_NPC_EnemySentry_Breakdown_C::DodgeCD_Max_' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, IsAimMe) == 0x00090C, "Member 'ABP_NPC_EnemySentry_Breakdown_C::IsAimMe' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, IsPlayDodge) == 0x00090D, "Member 'ABP_NPC_EnemySentry_Breakdown_C::IsPlayDodge' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, RunHurtAM) == 0x000910, "Member 'ABP_NPC_EnemySentry_Breakdown_C::RunHurtAM' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, CrouchHurtAM) == 0x000920, "Member 'ABP_NPC_EnemySentry_Breakdown_C::CrouchHurtAM' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, StandHurtAM) == 0x000930, "Member 'ABP_NPC_EnemySentry_Breakdown_C::StandHurtAM' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, FireAM) == 0x000940, "Member 'ABP_NPC_EnemySentry_Breakdown_C::FireAM' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, ReloadAM) == 0x000950, "Member 'ABP_NPC_EnemySentry_Breakdown_C::ReloadAM' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, AimPitch) == 0x000960, "Member 'ABP_NPC_EnemySentry_Breakdown_C::AimPitch' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, DTime) == 0x000964, "Member 'ABP_NPC_EnemySentry_Breakdown_C::DTime' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, AnimBP) == 0x000968, "Member 'ABP_NPC_EnemySentry_Breakdown_C::AnimBP' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, MiniBreakThreshold) == 0x000970, "Member 'ABP_NPC_EnemySentry_Breakdown_C::MiniBreakThreshold' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, MaxBreakThreshold) == 0x000974, "Member 'ABP_NPC_EnemySentry_Breakdown_C::MaxBreakThreshold' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, IsMoving) == 0x000978, "Member 'ABP_NPC_EnemySentry_Breakdown_C::IsMoving' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, IsHurting) == 0x000979, "Member 'ABP_NPC_EnemySentry_Breakdown_C::IsHurting' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, IsReloading) == 0x00097A, "Member 'ABP_NPC_EnemySentry_Breakdown_C::IsReloading' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, State) == 0x00097C, "Member 'ABP_NPC_EnemySentry_Breakdown_C::State' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, MoveTargetLocation) == 0x000980, "Member 'ABP_NPC_EnemySentry_Breakdown_C::MoveTargetLocation' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, ShouldAttack) == 0x00098C, "Member 'ABP_NPC_EnemySentry_Breakdown_C::ShouldAttack' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, RandomCount) == 0x000990, "Member 'ABP_NPC_EnemySentry_Breakdown_C::RandomCount' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, Timespan) == 0x000994, "Member 'ABP_NPC_EnemySentry_Breakdown_C::Timespan' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, IsCrouch) == 0x000998, "Member 'ABP_NPC_EnemySentry_Breakdown_C::IsCrouch' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, Waypoint) == 0x0009A0, "Member 'ABP_NPC_EnemySentry_Breakdown_C::Waypoint' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, IsShowWayPoint) == 0x0009B0, "Member 'ABP_NPC_EnemySentry_Breakdown_C::IsShowWayPoint' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, FreshWayPointTime) == 0x0009B4, "Member 'ABP_NPC_EnemySentry_Breakdown_C::FreshWayPointTime' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, CheckAvoid) == 0x0009B8, "Member 'ABP_NPC_EnemySentry_Breakdown_C::CheckAvoid' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, FixedTargetLocation) == 0x0009BC, "Member 'ABP_NPC_EnemySentry_Breakdown_C::FixedTargetLocation' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, ShootAvoid) == 0x0009C8, "Member 'ABP_NPC_EnemySentry_Breakdown_C::ShootAvoid' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, LastLocation) == 0x0009CC, "Member 'ABP_NPC_EnemySentry_Breakdown_C::LastLocation' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, MovingStuckCheckTime) == 0x0009D8, "Member 'ABP_NPC_EnemySentry_Breakdown_C::MovingStuckCheckTime' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, GoToStartPathCheckTime) == 0x0009DC, "Member 'ABP_NPC_EnemySentry_Breakdown_C::GoToStartPathCheckTime' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, DeathCheck) == 0x0009E0, "Member 'ABP_NPC_EnemySentry_Breakdown_C::DeathCheck' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, TempTargetLocation) == 0x0009E4, "Member 'ABP_NPC_EnemySentry_Breakdown_C::TempTargetLocation' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, IsFirstSwitch) == 0x0009F0, "Member 'ABP_NPC_EnemySentry_Breakdown_C::IsFirstSwitch' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, IsAllowRollOffset) == 0x0009F1, "Member 'ABP_NPC_EnemySentry_Breakdown_C::IsAllowRollOffset' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, FireInterval) == 0x0009F4, "Member 'ABP_NPC_EnemySentry_Breakdown_C::FireInterval' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, IsForceStop) == 0x0009F8, "Member 'ABP_NPC_EnemySentry_Breakdown_C::IsForceStop' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, HitCount) == 0x0009FC, "Member 'ABP_NPC_EnemySentry_Breakdown_C::HitCount' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, ForceStopCheck) == 0x000A00, "Member 'ABP_NPC_EnemySentry_Breakdown_C::ForceStopCheck' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, BulletReloadCount) == 0x000A04, "Member 'ABP_NPC_EnemySentry_Breakdown_C::BulletReloadCount' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, IsStartAimRoll) == 0x000A08, "Member 'ABP_NPC_EnemySentry_Breakdown_C::IsStartAimRoll' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, NewVar_0_0) == 0x000A0C, "Member 'ABP_NPC_EnemySentry_Breakdown_C::NewVar_0_0' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, IsInFirstShow) == 0x000A18, "Member 'ABP_NPC_EnemySentry_Breakdown_C::IsInFirstShow' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, ShowUp) == 0x000A20, "Member 'ABP_NPC_EnemySentry_Breakdown_C::ShowUp' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, TempList) == 0x000A30, "Member 'ABP_NPC_EnemySentry_Breakdown_C::TempList' has a wrong offset!");
static_assert(offsetof(ABP_NPC_EnemySentry_Breakdown_C, FindTarget) == 0x000A40, "Member 'ABP_NPC_EnemySentry_Breakdown_C::FindTarget' has a wrong offset!");

}

